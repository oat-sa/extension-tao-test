{"version":3,"names":["define","_","areaBroker$1","Object","prototype","hasOwnProperty","call","requireAreas","areaBroker","partial","dataHolderFactory","map","Map","defaultObjects","forEach","entry","set","pluginFactory","plugin","partialRight","hostName","moment","uuid","momentTimezone_min","probeOverseerFactory","runner","collectEvent","probe","eventNs","name","probeHandler","now","data","id","type","timestamp","format","timezone","tz","timeZone","capture","context","apply","concat","slice","arguments","overseer","push","latency","collectLatencyEvent","events","eventName","listen","indexOf","on","startHandler","marker","stopHandler","last","args","findLast","immutableQueue","startEvents","stopEvents","queueStorage","probes","queue","writing","Promise","resolve","started","getStorage","getTestStore","getStore","then","newStorage","resetStorage","isPlainObject","isFunction","init","TypeError","add","isString","isEmpty","where","length","isArray","getQueue","storage","getItem","getProbes","setItem","flush","flushed","start","savedQueue","stop","removeHandler","off","removeItem","guess","Array","eventifier","providerRegistry","testRunnerFactory","providerName","providerRun","method","_len","_key","provider","pluginRun","execStack","getPlugins","all","reportError","err","trigger","dataHolder","pluginFactories","config","plugins","states","ready","render","finish","destroy","itemStates","getProvider","proxy","probeOverseer","testStore","getDataHolder","getAreaBroker","getName","setState","after","catch","loadItem","itemRef","itemData","setItemState","renderItem","unloadItem","omit","disableItem","getItemState","enableItem","setTestContext","setTestMap","getConfig","getOptions","options","getPlugin","getPluginsConfig","getPluginConfig","pluginName","pluginsConfig","loadAreaBroker","getProxy","loadProxy","Error","error","install","getProbeOverseer","loadProbeOverseer","loadTestStore","getPluginStore","loadedStore","reject","getState","active","getPersistentState","state","setPersistentState","stored","loaded","disabled","getTestData","get","setTestData","testData","getTestContext","testContext","getTestMap","testMap","loadDataHolder","next","scope","previous","jump","position","skip","direction","ref","exit","why","pause","resume","timeout","timer","destroyCleanUp","clear","validateProvider","async","delegator","tokenHandlerFactory","connectivity","proxyFactory","proxyName","getParams","params","mergedParams","merge","extraCallParams","getMiddlewares","list","middlewares","applyMiddlewares","request","response","command","middleware","series","status","delegate","fnName","_slice","initialized","contains","delegateProxy","communicator","communicatorPromise","testDataHolder","proxyAdapter","initConfig","defaults","_defaults","tokenHandler","onlineStatus","isOnline","use","each","cb","destroyCommunicator","setOnline","isOffline","setOffline","source","isConnectivityError","isObject","code","sent","getTokenHandler","hasCommunicator","getCommunicator","self","loadCommunicator","before","e","open","channel","handler","communicatorInstance","noop","send","message","addCallActionParams","sendVariables","variables","deferred","callTestAction","action","uri","submitItem","callItemAction","telemetry","signal","messages","msg","wrapper","pluginWrapper","loggerFactory","providerLoader","pluginLoader","itemRunner","loadTestRunnerProviders","providers","loadFromBundle","loadAndRegisterProvider","providersToLoad","target","registerProvider","addList","load","loadedProviders","registration","runnerProviders","itemRunnerProviders","register","communicatorProviders","proxyProviders","logger","warn","keys","providerType","debug","results","reduce","acc","value","assign","sampleProxy","component","runnerFactory","Handlebars","runnerComponentTpl","asString","html","Template","$","validateTestRunnerConfiguration","requiredProperties","some","property","join","getSelectedProvider","typeProviders","runnerComponentFactory","container","template","runnerComponent","getOption","getRunner","setTemplate","hide","runnerConfig","renderTo","getElement","defer","show","spread","destroying","removeAllListeners","depth0","helpers","partials","compilerInfo","store","testStoreLoader","testId","preselectedBackend","testMode","storeNames","volatiles","changeTracking","isStoreModeUnified","isUndefined","selectStoreMode","result","modes","unified","storeName","trackChange","isBoolean","isUnified","loadStore","keyPattern","RegExp","storeKey","key","getItems","entries","transform","test","replace","setVolatile","clearVolatileIfStoreChange","storeId","shouldClear","getIdentifier","savedStoreId","info","clearVolatileStores","clearing","storeInstance","startChangeTracking","hasChanges","resetChanges","remove","legacyStoreExp","removeStore","removeAll","getStorageIdentifier","legacyPrefixes","fragmented","getAll","validate","prefix","foundStores"],"sources":["/github/workspace/tao/views/build/config-wrap-start-default.js","../runner/areaBroker.js","../runner/dataHolder.js","../runner/plugin.js","../runner/probeOverseer.js","../runner/runner.js","../runner/proxy.js","../runner/providerLoader.js","../runner/proxy/sample.js","../runner/runnerComponent.js","../runner/testStore.js","module-create.js","/github/workspace/tao/views/build/config-wrap-end-default.js"],"sourcesContent":["\n","define('taoTests/runner/areaBroker',['lodash', 'ui/areaBroker'], function (_, areaBroker$1) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    areaBroker$1 = areaBroker$1 && Object.prototype.hasOwnProperty.call(areaBroker$1, 'default') ? areaBroker$1['default'] : areaBroker$1;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var requireAreas = ['content',\n    //where the content is renderer, for example an item\n    'toolbox',\n    //the place to add arbitrary tools, like a zoom, a comment box, etc.\n    'navigation',\n    //the navigation controls like next, previous, skip\n    'control',\n    //the control center of the test, progress, timers, etc.\n    'header',\n    //the area that could contains the test titles\n    'panel' //a panel to add more advanced GUI (item review, navigation pane, etc.)\n    ];\n\n    /**\n     * Creates an area broker with the required areas for the test runner.\n     *\n     * @see ui/areaBroker\n     *\n     * @param {jQueryElement|HTMLElement|String} $container - the main container\n     * @param {Object} mapping - keys are the area names, values are jQueryElement\n     * @returns {broker} the broker\n     * @throws {TypeError} without a valid container\n     */\n    var areaBroker = _.partial(areaBroker$1, requireAreas);\n\n    return areaBroker;\n\n});\n\n","define('taoTests/runner/dataHolder',[],function () { 'use strict';\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n\n    /**\n     * Holds the test runner data.\n     *\n     * @example\n     * var holder = holder();\n     * holder.get('testMap');\n     *\n     * @author Bertrand Chevrier <bertrand@taotesting.com>\n     */\n\n    /**\n     * @type {String[]} the list of default objects to create\n     */\n    const defaultObjects = ['testContext', 'testMap'];\n\n    /**\n     * Creates a new data holder,\n     * with default entries.\n     *\n     * @returns {Map} the holder\n     */\n    function dataHolderFactory() {\n      var map = new Map();\n      defaultObjects.forEach(function (entry) {\n        map.set(entry, {});\n      });\n      return map;\n    }\n\n    return dataHolderFactory;\n\n});\n\n","define('taoTests/runner/plugin',['lodash', 'core/plugin'], function (_, pluginFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    pluginFactory = pluginFactory && Object.prototype.hasOwnProperty.call(pluginFactory, 'default') ? pluginFactory['default'] : pluginFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n\n    /**\n     * A pluginFactory configured for the test runner\n     * @returns {Function} the preconfigured plugin factory\n     */\n    var plugin = _.partialRight(pluginFactory, {\n      //alias getHost to getTestRunner\n      hostName: 'testRunner'\n    });\n\n    return plugin;\n\n});\n\n","define('taoTests/runner/probeOverseer',['lodash', 'moment', 'lib/uuid', 'lib/moment-timezone.min'], function (_, moment, uuid, momentTimezone_min) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    moment = moment && Object.prototype.hasOwnProperty.call(moment, 'default') ? moment['default'] : moment;\n    uuid = uuid && Object.prototype.hasOwnProperty.call(uuid, 'default') ? uuid['default'] : uuid;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var timeZone = moment.tz.guess();\n    var slice = Array.prototype.slice;\n\n    /**\n     * Create the overseer intance\n     * @param {runner} runner - a instance of a test runner\n     * @returns {probeOverseer} the new probe overseer\n     * @throws TypeError if something goes wrong\n     */\n    function probeOverseerFactory(runner) {\n      // the created instance\n      var overseer;\n\n      // the list of registered probes\n      var probes = [];\n\n      //temp queue\n      var queue = [];\n\n      //immutable queue which will not be flushed\n      var immutableQueue = [];\n\n      /**\n       * @type {Storage} to store the collected events\n       */\n      var queueStorage;\n\n      /**\n       * @type {Promise} Promises chain to avoid write collisions\n       */\n      var writing = Promise.resolve();\n\n      //is the overseer started\n      var started = false;\n\n      /**\n       * Get the storage instance\n       * @returns {Promise} that resolves with the storage\n       */\n      var getStorage = function getStorage() {\n        if (queueStorage) {\n          return Promise.resolve(queueStorage);\n        }\n        return runner.getTestStore().getStore('test-probe').then(function (newStorage) {\n          queueStorage = newStorage;\n          return Promise.resolve(queueStorage);\n        });\n      };\n\n      /**\n       * Unset the storage instance\n       */\n      var resetStorage = function resetStorage() {\n        queueStorage = null;\n      };\n\n      /**\n       * Register the collection event of a probe against a runner\n       * @param {Object} probe - a valid probe\n       */\n      function collectEvent(probe) {\n        var eventNs = `.probe-${probe.name}`;\n\n        //event handler registered to collect data\n        var probeHandler = function probeHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n          overseer.push(data);\n        };\n\n        //fallback\n        if (probe.latency) {\n          return collectLatencyEvent(probe);\n        }\n        _.forEach(probe.events, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(probeHandler, eventName));\n        });\n      }\n      function collectLatencyEvent(probe) {\n        var eventNs = `.probe-${probe.name}`;\n\n        //start event handler registered to collect data\n        var startHandler = function startHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            marker: 'start',\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n          overseer.push(data);\n        };\n\n        //stop event handler registered to collect data\n        var stopHandler = function stopHandler() {\n          var now = moment();\n          var last;\n          var data = {\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n          var args = slice.call(arguments);\n          last = _.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'start'\n          });\n          if (last && !_.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'end',\n            id: last.id\n          })) {\n            data.id = last.id;\n            data.marker = 'end';\n            if (typeof probe.capture === 'function') {\n              data.context = probe.capture.apply(probe, [runner].concat(args));\n            }\n            overseer.push(data);\n          }\n        };\n\n        //fallback\n        if (!probe.latency) {\n          return collectEvent(probe);\n        }\n        _.forEach(probe.startEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(startHandler, eventName));\n        });\n        _.forEach(probe.stopEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(stopHandler, eventName));\n        });\n      }\n\n      //argument validation\n      if (!_.isPlainObject(runner) || !_.isFunction(runner.init) || !_.isFunction(runner.on)) {\n        throw new TypeError('Please set a test runner');\n      }\n\n      /**\n       * @typedef {probeOverseer}\n       */\n      overseer = {\n        /**\n         * Add a new probe\n         * @param {Object} probe\n         * @param {String} probe.name - the probe name\n         * @param {Boolean} [probe.latency = false] - simple or latency mode\n         * @param {String[]} [probe.events] - the list of events to listen (simple mode)\n         * @param {String[]} [probe.startEvents] - the list of events to mark the start (lantency mode)\n         * @param {String[]} [probe.stopEvents] - the list of events to mark the end (latency mode)\n         * @param {Function} [probe.capture] - lambda fn to define the data context, it receive the test runner and the event parameters\n         * @returns {probeOverseer} chains\n         * @throws TypeError if the probe is not well formatted\n         */\n        add: function add(probe) {\n          // probe structure strict validation\n\n          if (!_.isPlainObject(probe)) {\n            throw new TypeError('A probe is a plain object');\n          }\n          if (!_.isString(probe.name) || _.isEmpty(probe.name)) {\n            throw new TypeError('A probe must have a name');\n          }\n          if (_.where(probes, {\n            name: probe.name\n          }).length > 0) {\n            throw new TypeError('A probe with this name is already regsitered');\n          }\n          if (probe.latency) {\n            if (_.isString(probe.startEvents) && !_.isEmpty(probe.startEvents)) {\n              probe.startEvents = [probe.startEvents];\n            }\n            if (_.isString(probe.stopEvents) && !_.isEmpty(probe.stopEvents)) {\n              probe.stopEvents = [probe.stopEvents];\n            }\n            if (!probe.startEvents.length || !probe.stopEvents.length) {\n              throw new TypeError('Latency based probes must have startEvents and stopEvents defined');\n            }\n\n            //if already started we register the events on addition\n            if (started) {\n              collectLatencyEvent(probe);\n            }\n          } else {\n            if (_.isString(probe.events) && !_.isEmpty(probe.events)) {\n              probe.events = [probe.events];\n            }\n            if (!_.isArray(probe.events) || probe.events.length === 0) {\n              throw new TypeError('A probe must define events');\n            }\n\n            //if already started we register the events on addition\n            if (started) {\n              collectEvent(probe);\n            }\n          }\n          probes.push(probe);\n          return this;\n        },\n        /**\n         * Get the time entries queue\n         * @returns {Promise} with the data in parameterj\n         */\n        getQueue: function getQueue() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue');\n          });\n        },\n        /**\n         * Get the list of defined probes\n         * @returns {Object[]} the probes collection\n         */\n        getProbes: function getProbes() {\n          return probes;\n        },\n        /**\n         * Push a time entry to the queue\n         * @param {Object} entry - the time entry\n         */\n        push: function push(entry) {\n          getStorage().then(function (storage) {\n            //ensure the queue is pushed to the store consistently and atomically\n            writing = writing.then(function () {\n              queue.push(entry);\n              immutableQueue.push(entry);\n              return storage.setItem('queue', queue);\n            });\n          });\n        },\n        /**\n         * Flush the queue and get the entries\n         * @returns {Promise} with the data in parameter\n         */\n        flush: function flush() {\n          return new Promise(function (resolve) {\n            getStorage().then(function (storage) {\n              writing = writing.then(function () {\n                return storage.getItem('queue').then(function (flushed) {\n                  queue = [];\n                  return storage.setItem('queue', queue).then(function () {\n                    resolve(flushed);\n                  });\n                });\n              });\n            });\n          });\n        },\n        /**\n         * Start the probes\n         * @returns {Promise} once started\n         */\n        start: function start() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue').then(function (savedQueue) {\n              if (_.isArray(savedQueue)) {\n                queue = savedQueue;\n                immutableQueue = savedQueue;\n              }\n              _.forEach(probes, collectEvent);\n              started = true;\n            });\n          });\n        },\n        /**\n         * Stop the probes\n         * Be carefull, stop will also clear the store and the queue\n         * @returns {Promise} once stopped\n         */\n        stop: function stop() {\n          started = false;\n          _.forEach(probes, function (probe) {\n            var eventNs = `.probe-${probe.name}`;\n            var removeHandler = function removeHandler(eventName) {\n              runner.off(eventName + eventNs);\n            };\n            _.forEach(probe.startEvents, removeHandler);\n            _.forEach(probe.stopEvents, removeHandler);\n            _.forEach(probe.events, removeHandler);\n          });\n          queue = [];\n          immutableQueue = [];\n          return getStorage().then(function (storage) {\n            return storage.removeItem('queue').then(resetStorage);\n          });\n        }\n      };\n      return overseer;\n    }\n\n    return probeOverseerFactory;\n\n});\n\n","define('taoTests/runner/runner',['lodash', 'core/eventifier', 'core/providerRegistry', 'taoTests/runner/dataHolder'], function (_, eventifier, providerRegistry, dataHolderFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    dataHolderFactory = dataHolderFactory && Object.prototype.hasOwnProperty.call(dataHolderFactory, 'default') ? dataHolderFactory['default'] : dataHolderFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2020 (original work) Open Assessment Technologies SA ;\n     */\n\n    /**\n     * Builds an instance of the QTI test runner\n     *\n     * @param {String} providerName\n     * @param {Function[]} pluginFactories\n     * @param {Object} config\n     * @param {String} config.serviceCallId - the identifier of the test session\n     * @param {String} [config.testDefinition] - the identifier of the test definition\n     * @param {String} [config.testCompilation] - the identifier of the compiled test\n     * @param {Object} config.options - the test runner configuration options\n     * @param {Object} config.options.plugins - the plugins configuration\n     * @param {jQueryElement} [config.renderTo] - the dom element that is going to holds the test content (item, rubick, etc)\n     * @returns {runner}\n     */\n    function testRunnerFactory(providerName) {\n      let pluginFactories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      /**\n       * @type {Object} The test runner instance\n       */\n      let runner;\n\n      /**\n       * @type {Map} Contains the test runner data\n       */\n      let dataHolder;\n\n      /**\n       * @type {Object} the registered plugins\n       */\n      const plugins = {};\n\n      /**\n       * @type {Object} the test of the runner\n       */\n      const states = {\n        init: false,\n        ready: false,\n        render: false,\n        finish: false,\n        destroy: false\n      };\n\n      /**\n       * @type {Object} keeps the states of the items\n       */\n      let itemStates = {};\n\n      /**\n       * The selected test runner provider\n       */\n      const provider = testRunnerFactory.getProvider(providerName);\n\n      /**\n       * Keep the area broker instance\n       * @see taoTests/runner/areaBroker\n       */\n      let areaBroker;\n\n      /**\n       * Keep the proxy instance\n       * @see taoTests/runner/proxy\n       */\n      let proxy;\n\n      /**\n       * Keep the instance of the probes overseer\n       * @see taoTests/runner/probeOverseer\n       */\n      let probeOverseer;\n\n      /**\n       * Keep the instance of a testStore\n       * @see taoTests/runner/testStore\n       */\n      let testStore;\n\n      /**\n       * Run a method of the provider (by delegation)\n       *\n       * @param {String} method - the method to run\n       * @param {...} args - rest parameters given to the provider method\n       * @returns {Promise} so provider can do async stuffs\n       */\n      function providerRun(method) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return new Promise(resolve => {\n          if (!_.isFunction(provider[method])) {\n            return resolve();\n          }\n          return resolve(provider[method].apply(runner, args));\n        });\n      }\n\n      /**\n       * Run a method in all plugins\n       *\n       * @param {String} method - the method to run\n       * @returns {Promise} once that resolve when all plugins are done\n       */\n      function pluginRun(method) {\n        var execStack = [];\n        _.forEach(runner.getPlugins(), plugin => {\n          if (_.isFunction(plugin[method])) {\n            execStack.push(plugin[method]());\n          }\n        });\n        return Promise.all(execStack);\n      }\n\n      /**\n       * Trigger error event\n       * @param {Error|String} err - the error\n       * @fires runner#error\n       */\n      function reportError(err) {\n        runner.trigger('error', err);\n      }\n\n      /**\n       * Defines the test runner\n       *\n       * @type {runner}\n       */\n      runner = eventifier({\n        /**\n         * Initialize the runner\n         *  - instantiate the plugins\n         *  - provider init\n         *  - plugins init\n         *  - call render\n         * @fires runner#init\n         * @returns {runner} chains\n         */\n        init() {\n          if (!dataHolder) {\n            dataHolder = this.getDataHolder();\n          }\n\n          //instantiate the plugins first\n          _.forEach(pluginFactories, pluginFactory => {\n            const plugin = pluginFactory(runner, this.getAreaBroker());\n            plugins[plugin.getName()] = plugin;\n          });\n          providerRun('install').then(_.partial(providerRun, 'loadPersistentStates')).then(_.partial(pluginRun, 'install')).then(_.partial(providerRun, 'init')).then(_.partial(pluginRun, 'init')).then(() => {\n            this.setState('init', true).off('init.internal').after('init.internal', () => this.render()).trigger('init');\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Render the runner\n         *  - provider render\n         *  - plugins render\n         * @fires runner#render\n         * @fires runner#ready\n         * @returns {runner} chains\n         */\n        render() {\n          providerRun('render').then(() => pluginRun('render')).then(() => {\n            this.setState('ready', true).trigger('render').trigger('ready');\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Load an item\n         *  - provider loadItem, resolve or return the itemData\n         *  - plugins loadItem\n         *  - call renderItem\n         * @param {*} itemRef - something that let you identify the item to load\n         * @fires runner#loaditem\n         * @returns {runner} chains\n         */\n        loadItem(itemRef) {\n          providerRun('loadItem', itemRef).then(itemData => {\n            this.setItemState(itemRef, 'loaded', true).off('loaditem.internal').after('loaditem.internal', () => this.renderItem(itemRef, itemData)).trigger('loaditem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Render an item\n         *  - provider renderItem\n         *  - plugins renderItem\n         * @param {Object} itemRef\n         * @param {Object} itemData - the loaded item data\n         * @fires runner#renderitem\n         * @returns {runner} chains\n         */\n        renderItem(itemRef, itemData) {\n          providerRun('renderItem', itemRef, itemData).then(() => {\n            this.setItemState(itemRef, 'ready', true).trigger('renderitem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Unload an item (for example to destroy the item)\n         *  - provider unloadItem\n         *  - plugins unloadItem\n         * @param {*} itemRef - something that let you identify the item to unload\n         * @fires runner#unloaditem\n         * @returns {runner} chains\n         */\n        unloadItem(itemRef) {\n          providerRun('unloadItem', itemRef).then(() => {\n            itemStates = _.omit(itemStates, itemRef);\n            this.trigger('unloaditem', itemRef);\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Disable an item\n         *  - provider disableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        disableItem(itemRef) {\n          if (!this.getItemState(itemRef, 'disabled')) {\n            providerRun('disableItem', itemRef).then(() => {\n              this.setItemState(itemRef, 'disabled', true).trigger('disableitem', itemRef);\n            }).catch(reportError);\n          }\n          return this;\n        },\n        /**\n         * Enable an item\n         *  - provider enableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        enableItem(itemRef) {\n          if (this.getItemState(itemRef, 'disabled')) {\n            providerRun('enableItem', itemRef).then(() => {\n              this.setItemState(itemRef, 'disabled', false).trigger('enableitem', itemRef);\n            }).catch(reportError);\n          }\n          return this;\n        },\n        /**\n         * When the test is terminated\n         *  - provider finish\n         *  - plugins finsh\n         * @fires runner#finish\n         * @returns {runner} chains\n         */\n        finish() {\n          providerRun('finish').then(() => pluginRun('finish')).then(() => {\n            this.setState('finish', true).trigger('finish');\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Flushes the runner\n         *  - provider flush\n         *  - plugins flush\n         * @fires runner#flush\n         * @returns {runner} chains\n         */\n        flush() {\n          providerRun('flush').then(() => pluginRun('flush')).then(() => {\n            this.setState('flush', true).trigger('flush');\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Destroy\n         *  - provider destroy\n         *  - plugins destroy\n         * @fires runner#destroy\n         * @returns {runner} chains\n         */\n        destroy() {\n          providerRun('destroy').then(() => pluginRun('destroy')).then(() => {\n            if (proxy) {\n              return proxy.destroy();\n            }\n          }).then(() => {\n            this.setTestContext({}).setTestMap({}).setState('destroy', true).trigger('destroy');\n          }).catch(reportError);\n          return this;\n        },\n        /**\n         * Get the whole test runner configuration\n         * @returns {Object} the config\n         */\n        getConfig() {\n          return config || {};\n        },\n        /**\n         * Get the options from the configuration parameters, (feature flags, parameter values, etc.)\n         *\n         * Alias to getConfig().options\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getOptions() {\n          return this.getConfig().options || {};\n        },\n        /**\n         * Get the runner pugins\n         * @returns {plugin[]} the plugins\n         */\n        getPlugins() {\n          return plugins;\n        },\n        /**\n         * Get a plugin\n         * @param {String} name - the plugin name\n         * @returns {plugin} the plugin\n         */\n        getPlugin(name) {\n          return plugins[name];\n        },\n        /**\n         * Get the configuration of the plugins\n         *\n         * Alias to getConfig().options.plugins\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getPluginsConfig() {\n          return this.getOptions().plugins || {};\n        },\n        /**\n         * Get the configuration of a given plugin\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @param {String} pluginName - the name of the plugin\n         * @returns {Object} the configuration options of the plugin\n         */\n        getPluginConfig(pluginName) {\n          if (pluginName && plugins[pluginName]) {\n            const pluginsConfig = this.getPluginsConfig();\n            if (pluginsConfig[pluginName]) {\n              return pluginsConfig[pluginName];\n            }\n          }\n          return {};\n        },\n        /**\n         * Get the area broker, load it if not present\n         *\n         * @returns {areaBroker} the areaBroker\n         */\n        getAreaBroker() {\n          if (!areaBroker) {\n            areaBroker = provider.loadAreaBroker.call(this);\n          }\n          return areaBroker;\n        },\n        /**\n         * Get the proxy, load it if not present\n         *\n         * @returns {proxy} the proxy\n         */\n        getProxy() {\n          if (!proxy) {\n            if (!_.isFunction(provider.loadProxy)) {\n              throw new Error('The provider does not have a loadProxy method');\n            }\n            proxy = provider.loadProxy.call(this);\n            proxy.on('error', error => this.trigger('error', error));\n            proxy.install(this.getDataHolder());\n          }\n          return proxy;\n        },\n        /**\n         * Get the probeOverseer, and load it if not present\n         *\n         * @returns {probeOverseer} the probe overseer\n         */\n        getProbeOverseer() {\n          if (!probeOverseer && _.isFunction(provider.loadProbeOverseer)) {\n            probeOverseer = provider.loadProbeOverseer.call(this);\n          }\n          return probeOverseer;\n        },\n        /**\n         * Get the testStore, and load it if not present\n         *\n         * @returns {testStore} the testStore instance\n         */\n        getTestStore() {\n          if (!testStore && _.isFunction(provider.loadTestStore)) {\n            testStore = provider.loadTestStore.call(this);\n          }\n          return testStore;\n        },\n        /**\n         * Get a plugin store.\n         * It's a convenience method that calls testStore.getStore\n         * @param {String} name - the name of store, usually the plugin name.\n         *\n         * @returns {Promise<storage>} the plugin store\n         */\n        getPluginStore(name) {\n          const loadedStore = this.getTestStore();\n          if (!loadedStore || !_.isFunction(loadedStore.getStore)) {\n            return Promise.reject(new Error('Please configure a testStore via loadTestStore to be able to get a plugin store'));\n          }\n          return this.getTestStore().getStore(name);\n        },\n        /**\n         * Check a runner state\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getState(name) {\n          return !!states[name];\n        },\n        /**\n         * Define a runner state\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         * @throws {TypeError} if the state name is not a valid string\n         */\n        setState(name, active) {\n          if (!_.isString(name) || _.isEmpty(name)) {\n            throw new TypeError('The state must have a name');\n          }\n          states[name] = !!active;\n          return this;\n        },\n        /**\n         * Checks a runner persistent state\n         *  - provider getPersistentState\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getPersistentState(name) {\n          let state;\n          if (_.isFunction(provider.getPersistentState)) {\n            state = provider.getPersistentState.call(runner, name);\n          }\n          return !!state;\n        },\n        /**\n         * Defines a runner persistent state\n         *  - provider setPersistentState\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {Promise} Returns a promise that:\n         *                      - will be resolved once the state is fully stored\n         *                      - will be rejected if any error occurs or if the state name is not a valid string\n         */\n        setPersistentState(name, active) {\n          let stored;\n          if (!_.isString(name) || _.isEmpty(name)) {\n            stored = Promise.reject(new TypeError('The state must have a name'));\n          } else {\n            stored = providerRun('setPersistentState', name, !!active);\n          }\n          stored.catch(reportError);\n          return stored;\n        },\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        getItemState(itemRef, name) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n          return !!(itemStates[itemRef] && itemStates[itemRef][name]);\n        },\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        setItemState(itemRef, name, active) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n          itemStates[itemRef] = itemStates[itemRef] || {\n            loaded: false,\n            ready: false,\n            disabled: false\n          };\n          itemStates[itemRef][name] = !!active;\n          return this;\n        },\n        /**\n         * Get the test data/definition\n         * @deprecated\n         * @returns {Object} the test data\n         */\n        getTestData() {\n          return dataHolder && dataHolder.get('testData');\n        },\n        /**\n         * Set the test data/definition\n         * @deprecated\n         * @param {Object} testData - the test data\n         * @returns {runner} chains\n         */\n        setTestData(testData) {\n          if (dataHolder && _.isPlainObject(testData)) {\n            dataHolder.set('testData', testData);\n          }\n          return this;\n        },\n        /**\n         * Get the test context/state\n         * @returns {Object} the test context\n         */\n        getTestContext() {\n          return dataHolder && dataHolder.get('testContext');\n        },\n        /**\n         * Set the test context/state\n         * @param {Object} testContext - the context to set\n         * @returns {runner} chains\n         */\n        setTestContext(testContext) {\n          if (dataHolder && _.isPlainObject(testContext)) {\n            dataHolder.set('testContext', testContext);\n          }\n          return this;\n        },\n        /**\n         * Get the test items map\n         * @returns {Object} the test map\n         */\n        getTestMap() {\n          return dataHolder && dataHolder.get('testMap');\n        },\n        /**\n         * Set the test items map\n         * @param {Object} testMap - the map to set\n         * @returns {runner} chains\n         */\n        setTestMap(testMap) {\n          if (dataHolder && _.isPlainObject(testMap)) {\n            dataHolder.set('testMap', testMap);\n          }\n          return this;\n        },\n        /**\n         * Get the data holder\n         * @returns {dataHolder}\n         */\n        getDataHolder() {\n          if (!dataHolder) {\n            if (_.isFunction(provider.loadDataHolder)) {\n              dataHolder = provider.loadDataHolder.call(this);\n            } else {\n              dataHolder = dataHolderFactory();\n            }\n          }\n          return dataHolder;\n        },\n        /**\n         * Move next alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        next(scope) {\n          if (_.isFunction(provider.next)) {\n            return providerRun('next', scope);\n          }\n\n          //backward compat\n          this.trigger('move', 'next', scope);\n          return this;\n        },\n        /**\n         * Move previous alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        previous(scope) {\n          if (_.isFunction(provider.previous)) {\n            return providerRun('previous', scope);\n          }\n\n          //backward compat\n          this.trigger('move', 'previous', scope);\n          return this;\n        },\n        /**\n         * Move to alias\n         * @param {String|Number} position - where to jump\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        jump(position, scope) {\n          if (_.isFunction(provider.jump)) {\n            return providerRun('jump', position, scope);\n          }\n\n          //backward compat\n          this.trigger('move', 'jump', scope, position);\n          return this;\n        },\n        /**\n         * Skip alias\n         * @param {String|*} [scope] - the movement scope\n         * @param {String|*} [direction] - next/previous/jump\n         * @param {Number|*} [ref] - the item ref\n         * @fires runner#skip\n         * @returns {runner} chains\n         */\n        skip(scope, direction, ref) {\n          if (_.isFunction(provider.skip)) {\n            return providerRun('skip', scope, direction, ref);\n          }\n\n          //backward compat\n          this.trigger('skip', scope, direction, ref);\n          return this;\n        },\n        /**\n         * Exit the test\n         * @param {String|*} [why] - reason the test is exited\n         * @fires runner#exit\n         * @returns {runner} chains\n         */\n        exit(why) {\n          if (_.isFunction(provider.exit)) {\n            return providerRun('exit', why);\n          }\n\n          //backward compat\n          this.trigger('exit', why);\n          return this;\n        },\n        /**\n         * Pause the current execution\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        pause() {\n          if (_.isFunction(provider.pause)) {\n            if (!this.getState('pause')) {\n              this.setState('pause', true);\n              return providerRun('pause');\n            }\n            return Promise.resolve();\n          }\n\n          //backward compat\n          if (!this.getState('pause')) {\n            this.setState('pause', true).trigger('pause');\n          }\n          return this;\n        },\n        /**\n         * Resume a paused test\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        resume() {\n          if (_.isFunction(provider.resume)) {\n            if (this.getState('pause')) {\n              this.setState('pause', false);\n              return providerRun('resume');\n            }\n            return Promise.resolve();\n          }\n\n          //backward compat\n          if (this.getState('pause') === true) {\n            this.setState('pause', false).trigger('resume');\n          }\n          return this;\n        },\n        /**\n         * Notify a test timeout\n         * @param {String} scope - The scope where the timeout occurred\n         * @param {String} ref - The reference to the place where the timeout occurred\n         * @param {Object} [timer] - The timer's descriptor, if any\n         * @fires runner#timeout\n         * @returns {runner} chains\n         */\n        timeout(scope, ref, timer) {\n          if (_.isFunction(provider.timeout)) {\n            return providerRun('timeout', scope, ref, timer);\n          }\n\n          //backward compat\n          this.trigger('timeout', scope, ref, timer);\n          return this;\n        }\n      });\n      runner.on('move', function () {\n        this.trigger(...arguments);\n      }).after('destroy', function destroyCleanUp() {\n        if (dataHolder) {\n          dataHolder.clear();\n        }\n        areaBroker = null;\n        proxy = null;\n        probeOverseer = null;\n        testStore = null;\n      });\n      return runner;\n    }\n\n    //bind the provider registration capabilities to the testRunnerFactory\n    var runner = providerRegistry(testRunnerFactory, function validateProvider(provider) {\n      //mandatory methods\n      if (!_.isFunction(provider.loadAreaBroker)) {\n        throw new TypeError('The runner provider MUST have a method that returns an areaBroker');\n      }\n      return true;\n    });\n\n    return runner;\n\n});\n\n","define('taoTests/runner/proxy',['lodash', 'async', 'core/delegator', 'core/eventifier', 'core/providerRegistry', 'core/tokenHandler', 'core/connectivity'], function (_, async, delegator, eventifier, providerRegistry, tokenHandlerFactory, connectivity) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    async = async && Object.prototype.hasOwnProperty.call(async, 'default') ? async['default'] : async;\n    delegator = delegator && Object.prototype.hasOwnProperty.call(delegator, 'default') ? delegator['default'] : delegator;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    tokenHandlerFactory = tokenHandlerFactory && Object.prototype.hasOwnProperty.call(tokenHandlerFactory, 'default') ? tokenHandlerFactory['default'] : tokenHandlerFactory;\n    connectivity = connectivity && Object.prototype.hasOwnProperty.call(connectivity, 'default') ? connectivity['default'] : connectivity;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    var _defaults = {};\n    var _slice = [].slice;\n\n    /**\n     * Defines a proxy bound to a particular adapter\n     *\n     * @param {String} proxyName - The name of the proxy adapter to use in the returned proxy instance\n     * @param {Object} [config] - Some optional config depending of implementation,\n     *                            this object will be forwarded to the proxy adapter\n     * @returns {proxy} - The proxy instance, bound to the selected proxy adapter\n     */\n    function proxyFactory(proxyName, config) {\n      var proxy, delegateProxy, communicator, communicatorPromise;\n      var testDataHolder;\n      var extraCallParams = {};\n      var proxyAdapter = proxyFactory.getProvider(proxyName);\n      var initConfig = _.defaults(config || {}, _defaults);\n      var tokenHandler = tokenHandlerFactory();\n      var middlewares = {};\n      var initialized = false;\n      var onlineStatus = connectivity.isOnline();\n\n      /**\n       * Gets parameters merged with extra parameters\n       * @param {Object} [params]\n       * @returns {Object}\n       */\n      function getParams(params) {\n        var mergedParams = _.merge({}, params, extraCallParams);\n        extraCallParams = {};\n        return mergedParams;\n      }\n\n      /**\n       * Gets the aggregated list of middlewares for a particular queue name\n       * @param {String} queue - The name of the queue to get\n       * @returns {Array}\n       */\n      function getMiddlewares(queue) {\n        var list = middlewares[queue] || [];\n        if (middlewares.all) {\n          list = list.concat(middlewares.all);\n        }\n        return list;\n      }\n\n      /**\n       * Applies the list of registered middlewares onto the received response\n       * @param {Object} request - The request descriptor\n       * @param {String} request.command - The name of the requested command\n       * @param {Object} request.params - The map of provided parameters\n       * @param {Object} response The response descriptor\n       * @param {String} response.status The status of the response, can be either 'success' or 'error'\n       * @param {Object} response.data The full response data\n       * @returns {Promise}\n       */\n      function applyMiddlewares(request, response) {\n        // wrap each middleware to provide parameters\n        var list = _.map(getMiddlewares(request.command), function (middleware) {\n          return function (next) {\n            middleware(request, response, next);\n          };\n        });\n\n        // apply each middleware in series, then resolve or reject the promise\n        return new Promise(function (resolve, reject) {\n          async.series(list, function (err) {\n            // handle implicit error from response descriptor\n            if (!err && 'error' === response.status) {\n              err = response.data;\n            }\n            if (err) {\n              reject(err);\n            } else {\n              proxy.trigger('receive', response.data, 'proxy');\n              resolve(response.data);\n            }\n          });\n        });\n      }\n\n      /**\n       * Delegates the call to the proxy implementation and apply the middleware.\n       *\n       * @param {String} fnName - The name of the delegated method to call\n       * @returns {Promise} - The delegated method must return a promise\n       * @private\n       * @throws Error\n       */\n      function delegate(fnName) {\n        var request = {\n          command: fnName,\n          params: _slice.call(arguments, 1)\n        };\n        if (!initialized && !_.contains(['install', 'init'], fnName)) {\n          return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n        }\n        return delegateProxy.apply(null, arguments).then(function (data) {\n          // If the delegate call succeed the proxy is initialized.\n          // Place this set here to avoid to wrap the init() into another promise.\n          initialized = true;\n\n          // handle successful request\n          return applyMiddlewares(request, {\n            status: 'success',\n            data: data\n          });\n        }).catch(function (data) {\n          // handle failed request\n          return applyMiddlewares(request, {\n            status: 'error',\n            data: data\n          });\n        });\n      }\n\n      /**\n       * Defines the test runner proxy\n       * @typedef {proxy}\n       */\n      proxy = eventifier({\n        /**\n         * Add a middleware\n         * @param {String} [command] The command queue in which add the middleware (default: 'all')\n         * @param {Function...} callback - A middleware callback. Must accept 3 parameters: request, response, next.\n         * @returns {proxy}\n         */\n        use: function use(command) {\n          var queue = command && _.isString(command) ? command : 'all';\n          var list = middlewares[queue] || [];\n          middlewares[queue] = list;\n          _.each(arguments, function (cb) {\n            if (_.isFunction(cb)) {\n              list.push(cb);\n            }\n          });\n          return this;\n        },\n        /**\n         * Install the proxy.\n         * This step let's attach some features before the proxy reallys starts (before init).\n         *\n         * @param {Map} dataHolder - the test runner data holder\n         * @returns {*}\n         */\n        install: function install(dataHolder) {\n          if (dataHolder) {\n            testDataHolder = dataHolder;\n          }\n          return delegate('install', initConfig);\n        },\n        /**\n         * Initializes the proxy\n         * @param {Object} [params] - An optional list of parameters\n         * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires init\n         */\n        init: function init(params) {\n          /**\n           * @event proxy#init\n           * @param {Promise} promise\n           * @param {Object} config\n           * @param {Object} params\n           */\n          return delegate('init', initConfig, getParams(params));\n        },\n        /**\n         * Uninstalls the proxy\n         * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires destroy\n         */\n        destroy: function destroy() {\n          /**\n           * @event proxy#destroy\n           * @param {Promise} promise\n           */\n          return delegate('destroy').then(function () {\n            // The proxy is now destroyed. A call to init() is mandatory to be able to use it again.\n            initialized = false;\n\n            // a communicator has been invoked and...\n            if (communicatorPromise) {\n              return new Promise(function (resolve, reject) {\n                function destroyCommunicator() {\n                  communicator.destroy().then(resolve).catch(reject);\n                }\n                communicatorPromise\n                // ... has been loaded successfully, then destroy it\n                .then(function () {\n                  destroyCommunicator();\n                })\n                // ...has failed to be loaded, maybe no need to destroy it\n                .catch(function () {\n                  if (communicator) {\n                    destroyCommunicator();\n                  } else {\n                    resolve();\n                  }\n                });\n              });\n            }\n          });\n        },\n        /**\n         * Get the map that holds the test data\n         * @returns {Map|Object} the dataHolder\n         */\n        getDataHolder: function getDataHolder() {\n          return testDataHolder;\n        },\n        /**\n         * Set the proxy as online\n         * @returns {proxy} chains\n         * @fires {proxy#reconnect}\n         */\n        setOnline: function setOnline() {\n          if (this.isOffline()) {\n            onlineStatus = true;\n            this.trigger('reconnect');\n          }\n          return this;\n        },\n        /**\n         * Set the proxy as offline\n         * @param {String} [source] - source of the connectivity change\n         * @returns {proxy} chains\n         * @fires {proxy#disconnect}\n         */\n        setOffline: function setOffline(source) {\n          if (this.isOnline()) {\n            onlineStatus = false;\n            this.trigger('disconnect', source);\n          }\n          return this;\n        },\n        /**\n         * Are we online ?\n         * @returns {Boolean}\n         */\n        isOnline: function isOnline() {\n          return onlineStatus;\n        },\n        /**\n         * Are we offline\n         * @returns {Boolean}\n         */\n        isOffline: function isOffline() {\n          return !onlineStatus;\n        },\n        /**\n         * For the proxy a connection error is an error object with\n         * source 'network', a 0 code and a false sent attribute.\n         *\n         * @param {Error|Object} err - the error to verify\n         * @returns {Boolean} true if a connection error.\n         */\n        isConnectivityError: function isConnectivityError(err) {\n          return _.isObject(err) && err.source === 'network' && err.code === 0 && err.sent === false;\n        },\n        /**\n         * Gets the security token handler\n         * @returns {tokenHandler}\n         */\n        getTokenHandler: function getTokenHandler() {\n          return tokenHandler;\n        },\n        /**\n         * Checks if a communication channel has been requested.\n         * @returns {Boolean}\n         */\n        hasCommunicator: function hasCommunicator() {\n          return !!communicatorPromise;\n        },\n        /**\n         * Gets access to the communication channel, load it if not present\n         * @returns {Promise} Returns a promise that will resolve the communication channel\n         */\n        getCommunicator: function getCommunicator() {\n          var self = this;\n          if (!initialized) {\n            return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n          }\n          if (!communicatorPromise) {\n            communicatorPromise = new Promise(function (resolve, reject) {\n              if (_.isFunction(proxyAdapter.loadCommunicator)) {\n                communicator = proxyAdapter.loadCommunicator.call(self);\n                if (communicator) {\n                  communicator.before('error', function (e, err) {\n                    if (self.isConnectivityError(err)) {\n                      self.setOffline('communicator');\n                    }\n                  }).on('error', function (err) {\n                    self.trigger('error', err);\n                  }).on('receive', function (response) {\n                    self.setOnline();\n                    self.trigger('receive', response, 'communicator');\n                  }).init().then(function () {\n                    return communicator.open().then(function () {\n                      resolve(communicator);\n                    }).catch(reject);\n                  }).catch(reject);\n                } else {\n                  reject(new Error('No communicator has been set up!'));\n                }\n              } else {\n                reject(new Error('The proxy provider does not have a loadCommunicator method'));\n              }\n            });\n          }\n          return communicatorPromise;\n        },\n        /**\n         * Registers a listener on a particular channel\n         * @param {String} name - The name of the channel to listen\n         * @param {Function} handler - The listener callback\n         * @returns {proxy}\n         * @throws TypeError if the name is missing or the handler is not a callback\n         */\n        channel: function channel(name, handler) {\n          if (!_.isString(name) || name.length <= 0) {\n            throw new TypeError('A channel must have a name');\n          }\n          if (!_.isFunction(handler)) {\n            throw new TypeError('A handler must be attached to a channel');\n          }\n          this.getCommunicator().then(function (communicatorInstance) {\n            communicatorInstance.channel(name, handler);\n          })\n          // just an empty catch to avoid any error to be displayed in the console when the communicator is not enabled\n          .catch(_.noop);\n          this.on(`channel-${name}`, handler);\n          return this;\n        },\n        /**\n         * Sends an messages through the communication implementation.\n         * @param {String} channel - The name of the communication channel to use\n         * @param {Object} message - The message to send\n         * @returns {Promise} The delegated provider's method must return a promise\n         */\n        send: function send(channel, message) {\n          return this.getCommunicator().then(function (communicatorInstance) {\n            return communicatorInstance.send(channel, message);\n          });\n        },\n        /**\n         * Add extra parameters that will be added to the init or the next callTestAction or callItemAction\n         * This enables plugins to place parameters for next calls\n         * @param {Object} params - the extra parameters\n         * @returns {proxy}\n         */\n        addCallActionParams: function addCallActionParams(params) {\n          if (_.isPlainObject(params)) {\n            _.merge(extraCallParams, params);\n          }\n          return this;\n        },\n        /**\n         * Gets the test definition data\n         * @deprecated\n         *\n         * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getTestData\n         */\n        getTestData: function getTestData() {\n          /**\n           * @event proxy#getTestData\n           * @param {Promise} promise\n           */\n          return delegate('getTestData');\n        },\n        /**\n         * Gets the test context\n         * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestContext: function getTestContext() {\n          /**\n           * @event proxy#getTestContext\n           * @param {Promise} promise\n           */\n          return delegate('getTestContext');\n        },\n        /**\n         * Gets the test map\n         * @returns {Promise} - Returns a promise. The test map object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestMap: function getTestMap() {\n          /**\n           * @event proxy#getTestMap\n           * @param {Promise} promise\n           */\n          return delegate('getTestMap');\n        },\n        /**\n         * Sends the test variables\n         * @param {Object} variables\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later (default: false).\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires sendVariables\n         */\n        sendVariables: function sendVariables(variables, deferred) {\n          /**\n           * @event proxy#sendVariables\n           * @param {Promise} promise\n           */\n          return delegate('sendVariables', variables, deferred);\n        },\n        /**\n         * Calls an action related to the test\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callTestAction\n         */\n        callTestAction: function callTestAction(action, params, deferred) {\n          /**\n           * @event proxy#callTestAction\n           * @param {Promise} promise\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callTestAction', action, getParams(params), deferred);\n        },\n        /**\n         * Gets an item definition by its URI, also gets its current state\n         * @param {String} uri - The URI of the item to get\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getItem\n         */\n        getItem: function getItem(uri, params) {\n          /**\n           * @event proxy#getItem\n           * @param {Promise} promise\n           * @param {String} uri\n           */\n          return delegate('getItem', uri, params);\n        },\n        /**\n         * Submits the state and the response of a particular item\n         * @param {String} uri - The URI of the item to update\n         * @param {Object} state - The state to submit\n         * @param {Object} response - The response object to submit\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires submitItem\n         */\n        submitItem: function submitItem(uri, state, response, params) {\n          /**\n           * @event proxy#submitItem\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {Object} state\n           * @param {Object} response\n           */\n          return delegate('submitItem', uri, state, response, getParams(params));\n        },\n        /**\n         * Calls an action related to a particular item\n         * @param {String} uri - The URI of the item for which call the action\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callItemAction\n         */\n        callItemAction: function callItemAction(uri, action, params, deferred) {\n          /**\n           * @event proxy#callItemAction\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callItemAction', uri, action, getParams(params), deferred);\n        },\n        /**\n         * Sends a telemetry signal\n         * @param {String} uri - The URI of the item for which sends the telemetry signal\n         * @param {String} signal - The name of the signal to send\n         * @param {Object} [params] - Some optional parameters to join to the signal\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires telemetry\n         */\n        telemetry: function telemetry(uri, signal, params) {\n          /**\n           * @event proxy#telemetry\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} signal\n           * @param {Object} params\n           */\n          return delegate('telemetry', uri, signal, params);\n        }\n      });\n\n      //listen for connectivty changes\n      connectivity.on('offline', function () {\n        proxy.setOffline('device');\n      }).on('online', function () {\n        proxy.setOnline();\n      });\n\n      // catch platform messages that come outside of the communicator component, then each is dispatched to the right channel\n      proxy.on('message', function (channel, message) {\n        this.trigger(`channel-${channel}`, message);\n      }).use(function (request, response, next) {\n        if (response.data && response.data.messages) {\n          // receive server messages\n          _.forEach(response.data.messages, function (msg) {\n            if (msg.channel) {\n              proxy.trigger('message', msg.channel, msg.message);\n            } else {\n              proxy.trigger('message', 'malformed', msg);\n            }\n          });\n        }\n        next();\n      })\n      //detect failing request and change the online status\n      .use(function (request, response, next) {\n        if (proxy.isConnectivityError(response.data)) {\n          proxy.setOffline('request');\n        } else if (response.data && response.data.sent === true) {\n          proxy.setOnline();\n        }\n        next();\n      });\n      delegateProxy = delegator(proxy, proxyAdapter, {\n        name: 'proxy',\n        wrapper: function pluginWrapper(response) {\n          return Promise.resolve(response);\n        }\n      });\n      return proxy;\n    }\n    var proxy = providerRegistry(proxyFactory);\n\n    return proxy;\n\n});\n\n","define('taoTests/runner/providerLoader',['core/logger', 'core/providerLoader', 'core/pluginLoader', 'core/communicator', 'taoTests/runner/runner', 'taoTests/runner/proxy', 'taoItems/runner/api/itemRunner'], function (loggerFactory, providerLoader, pluginLoader, communicator, runner, proxy, itemRunner) { 'use strict';\n\n    loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n    providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n    pluginLoader = pluginLoader && Object.prototype.hasOwnProperty.call(pluginLoader, 'default') ? pluginLoader['default'] : pluginLoader;\n    communicator = communicator && Object.prototype.hasOwnProperty.call(communicator, 'default') ? communicator['default'] : communicator;\n    runner = runner && Object.prototype.hasOwnProperty.call(runner, 'default') ? runner['default'] : runner;\n    proxy = proxy && Object.prototype.hasOwnProperty.call(proxy, 'default') ? proxy['default'] : proxy;\n    itemRunner = itemRunner && Object.prototype.hasOwnProperty.call(itemRunner, 'default') ? itemRunner['default'] : itemRunner;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2019 Open Assessment Technologies SA ;\n     */\n    const logger = loggerFactory('taoTests/runner/loader');\n\n    /**\n     * @typedef {Object} provider - A provider is an object exposing a list of methods with respect to the API managed by the target.\n     * @property {String} name - The name of the provider. It should be unique among all.\n     * @property {Function} init - Each provider much expose at least a method `init()`\n     * @property {Function} ... - Any other method the target is expecting\n     */\n\n    /**\n     * Load the providers that match the registration\n     * @param {Object} providers\n     * @param {provider|provider[]} providers.runner\n     * @param {provider|provider[]} [providers.proxy]\n     * @param {provider|provider[]} [providers.communicator]\n     * @param {provider|provider[]} [providers.plugins]\n     * @param {Boolean} loadFromBundle - does the loader load the modules from the sources (dev mode) or the bundles\n     * @returns {Promise<Object>} resolves with the loaded providers per provider type\n     */\n    function loadTestRunnerProviders() {\n      let providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let loadFromBundle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      /**\n       * Default way to load the modules and register the providers\n       * @param {Object[]} providersToLoad - the list of providers\n       * @param {Object} target - a provider target (an object that use the providers), it needs to expose registerProvider\n       * @returns {Promise<Object>} resolves with the target\n       * @throws {TypeError} if the target is not a provider target\n       */\n      const loadAndRegisterProvider = function () {\n        let providersToLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let target = arguments.length > 1 ? arguments[1] : undefined;\n        if (!target || typeof target.registerProvider !== 'function') {\n          throw new TypeError('Trying to register providers on a target that is not a provider API');\n        }\n        return providerLoader().addList(providersToLoad).load(loadFromBundle).then(loadedProviders => {\n          loadedProviders.forEach(provider => target.registerProvider(provider.name, provider));\n          return target;\n        });\n      };\n\n      /**\n       * Available provider registration\n       */\n      const registration = {\n        runner() {\n          let runnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(runnerProviders, runner);\n        },\n        itemRunner() {\n          let itemRunnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return providerLoader().addList(itemRunnerProviders).load(loadFromBundle).then(loadedProviders => {\n            loadedProviders.forEach(provider => itemRunner.register(provider.name, provider));\n            return itemRunner;\n          });\n        },\n        communicator() {\n          let communicatorProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(communicatorProviders, communicator);\n        },\n        proxy() {\n          let proxyProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(proxyProviders, proxy);\n        },\n        plugins() {\n          let plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return pluginLoader().addList(plugins).load(loadFromBundle);\n        }\n      };\n      if (!loadFromBundle) {\n        logger.warn('All modules will be loaded from sources');\n      }\n      return Promise.all(Object.keys(providers).map(providerType => {\n        if (typeof registration[providerType] === 'function') {\n          logger.debug(`Start to load and register the '${providerType}' providers`);\n          const providersToLoad = Array.isArray(providers[providerType]) ? providers[providerType] : [providers[providerType]];\n          return registration[providerType](providersToLoad).then(loaded => {\n            logger.debug(`'${providerType}' providers are loaded and registered`);\n            return {\n              [providerType]: loaded\n            };\n          });\n        } else {\n          logger.warn(`Ignoring the '${providerType}' providers loading, no registration method found`);\n        }\n      })).then(results => results.reduce((acc, value) => Object.assign(acc, value), {})).catch(err => {\n        logger.error(`Error in test runner providers and plugins loading : ${err.message}`);\n        throw err;\n      });\n    }\n\n    return loadTestRunnerProviders;\n\n});\n\n","define('taoTests/runner/proxy/sample',[],function () { 'use strict';\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * @author Jean-Sbastien Conan <jean-sebastien.conan@vesperiagroup.com>\n     */\n\n    /**\n     * Sample proxy definition\n     * @type {Object}\n     */\n    var sampleProxy = {\n      /**\n       * Initializes the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      init: function init() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do initialisation\n          // once the proxy has been fully initialized notify the success by resolving the promise\n          resolve();\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Uninstalls the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      destroy: function destroy() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do uninstall actions\n          // once the proxy has been fully uninstalled notify the success by resolving the promise\n          resolve();\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test definition data\n       * @param {Object} config - The config provided to the proxy factory\n       * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestData: function getTestData() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test definition data\n\n          // once the action has been processed notify the success by resolving the promise\n          resolve( /* the test definition data */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test context\n       * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestContext: function getTestContext() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test context object\n\n          // once the action has been processed notify the success by resolving the promise\n          resolve( /* the test context object */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to the test\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callTestAction: function callTestAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n\n          // once the action has been processed notify the success by resolving the promise\n          resolve( /* the action response */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets an item definition by its URI, also gets its current state\n       * @param {String} uri - The URI of the item to get\n       * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires getItem\n       */\n      getItem: function getItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the definition data and the state of the item\n          // once the item data is loaded provide the data by resolving the promise\n          resolve( /* the item data */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Submits the state and the response of a particular item\n       * @param {String} uri - The URI of the item to update\n       * @param {Object} state - The state to submit\n       * @param {Object} response - The response object to submit\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires submitItem\n       */\n      submitItem: function submitItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // submit the state and the response of the item\n\n          // once the data has been processed notify the success by resolving the promise\n          resolve( /* the action response */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to a particular item\n       * @param {String} uri - The URI of the item for which call the action\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callItemAction: function callItemAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n\n          // once the action has been processed notify the success by resolving the promise\n          resolve( /* the action response */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Sends a telemetry signal\n       * @param {String} uri - The URI of the item for which sends the telemetry signal\n       * @param {String} signal - The name of the signal to send\n       * @param {Object} [params] - Some optional parameters to join to the signal\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires telemetry\n       */\n      telemetry: function telemetry() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // send the signal\n\n          // once the signal has been processed notify the success by resolving the promise\n          resolve( /* the signal response */);\n\n          // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      }\n    };\n\n    return sampleProxy;\n\n});\n\n","define('taoTests/runner/runnerComponent',['lodash', 'ui/component', 'taoTests/runner/runner', 'taoTests/runner/providerLoader', 'handlebars'], function (_, component, runnerFactory, providerLoader, Handlebars) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    component = component && Object.prototype.hasOwnProperty.call(component, 'default') ? component['default'] : component;\n    runnerFactory = runnerFactory && Object.prototype.hasOwnProperty.call(runnerFactory, 'default') ? runnerFactory['default'] : runnerFactory;\n    providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n    Handlebars = Handlebars && Object.prototype.hasOwnProperty.call(Handlebars, 'default') ? Handlebars['default'] : Handlebars;\n\n    var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {\n      this.compilerInfo = [4,'>= 1.0.0'];\n    helpers = this.merge(helpers, Handlebars.helpers);  \n\n\n      return \"<div class=\\\"runner-component\\\"></div>\\n\";\n      });\n    function runnerComponentTpl(data, options, asString) {\n      var html = Template(data, options);\n      return (asString || true) ? html : $(html);\n    }\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA ;\n     */\n\n    /**\n     * Validate required options from the configuration\n     * @param {Object} config\n     * @returns {Boolean} true if valid\n     * @throws {TypeError} in case of validation failure\n     */\n    function validateTestRunnerConfiguration() {\n      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const requiredProperties = ['providers', 'options', 'serviceCallId'];\n      if (typeof config !== 'object') {\n        throw new TypeError(`The runner configuration must be an object, '${typeof config}' received`);\n      }\n      if (requiredProperties.some(property => typeof config[property] === 'undefined')) {\n        throw new TypeError(`The runner configuration must contains at least the following properties : ${requiredProperties.join(',')}`);\n      }\n      return true;\n    }\n\n    /**\n     * Get the selected provider if set or infer it from the providers list\n     * @param {String} type - the type of provider (runner, communicator, proxy, etc.)\n     * @param {Object} config\n     * @returns {String} the selected provider for the given type\n     */\n    function getSelectedProvider() {\n      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'runner';\n      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (config.provider && config.provider[type]) {\n        return config.provider[type];\n      }\n      if (config.providers && config.providers[type]) {\n        const typeProviders = config.providers[type];\n        if (typeof typeProviders === 'object' && (typeProviders.id || typeProviders.name)) {\n          return typeProviders.id || typeProviders.name;\n        }\n        if (Array.isArray(typeProviders) && typeProviders.length > 0) {\n          return typeProviders[0].id || typeProviders[0].name;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Wraps a test runner into a component\n     * @param {jQuery|HTMLElement|String} container - The container in which renders the component\n     * @param {Object} config - The component configuration options\n     * @param {String} config.serviceCallId - The identifier of the test session\n     * @param {Object} config.providers\n     * @param {Object} config.options\n     * @param {Boolean} [config.loadFromBundle=false] - do we load the modules from the bundles\n     * @param {Boolean} [config.replace] - When the component is appended to its container, clears the place before\n     * @param {Number|String} [config.width] - The width in pixels, or 'auto' to use the container's width\n     * @param {Number|String} [config.height] - The height in pixels, or 'auto' to use the container's height\n     * @param {Function} [template] - An optional template for the component\n     * @returns {runnerComponent}\n     */\n    function runnerComponentFactory() {\n      let container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let template = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : runnerComponentTpl;\n      let runner = null;\n      let plugins = [];\n      if (!container) {\n        throw new TypeError('A container element must be defined to contain the runnerComponent');\n      }\n      validateTestRunnerConfiguration(config);\n\n      /**\n       * @typedef {runner} runnerComponent\n       */\n      const runnerComponent = component({\n        /**\n         * Gets the option's value\n         * @param {String} name - the option key\n         * @returns {*}\n         */\n        getOption(name) {\n          return this.config.options[name];\n        },\n        /**\n         * Gets the test runner\n         * @returns {runner}\n         */\n        getRunner() {\n          return runner;\n        }\n      }).setTemplate(template).on('init', function () {\n        //load the defined providers for the runner, the proxy, the communicator, the plugins, etc.\n        return providerLoader(config.providers, config.loadFromBundle).then(results => {\n          if (results && results.plugins) {\n            plugins = results.plugins;\n          }\n          this.render(container);\n          this.hide();\n        }).catch(err => this.trigger('error', err));\n      }).on('render', function () {\n        const runnerConfig = Object.assign(_.omit(this.config, ['providers']), {\n          renderTo: this.getElement()\n        });\n        runnerConfig.provider = Object.keys(this.config.providers).reduce((acc, providerType) => {\n          if (!acc[providerType] && providerType !== 'plugins') {\n            acc[providerType] = getSelectedProvider(providerType, this.config);\n          }\n          return acc;\n        }, runnerConfig.provider || {});\n        runner = runnerFactory(runnerConfig.provider.runner, plugins, runnerConfig).on('ready', () => {\n          _.defer(() => {\n            this.setState('ready').trigger('ready', runner).show();\n          });\n        }).on('destroy', () => runner = null).spread(this, 'error').init();\n      }).on('destroy', function () {\n        var destroying = runner && runner.destroy();\n        runner = null;\n        return destroying;\n      }).after('destroy', function () {\n        this.removeAllListeners();\n      });\n      return runnerComponent.init(config);\n    }\n\n    return runnerComponentFactory;\n\n});\n\n","define('taoTests/runner/testStore',['lodash', 'core/store', 'core/logger'], function (_, store, loggerFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    store = store && Object.prototype.hasOwnProperty.call(store, 'default') ? store['default'] : store;\n    loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA\n     *\n     */\n\n    /**\n     * The test store logger\n     * @type {core/logger}\n     */\n    var logger = loggerFactory('taoQtiTest/runner/provider/testStore');\n\n    /**\n     * Database name prefix (suffixed by the test identifier)\n     * to check if we use the fragmented mode\n     * or the unified mode.\n     * @type {String[]}\n     */\n    var legacyPrefixes = ['actions-', 'duration-', 'test-probe', 'timer-'];\n\n    /**\n     * List the available modes\n     */\n    var modes = {\n      unified: 'unified',\n      //one db per test, new mode\n      fragmented: 'fragmented' //mutliple dbs per test, legacy mode\n    };\n\n    /**\n     * Check and select the store mode.\n     * If any of the \"legacyPrefixes\" store is found, we used the fragmented mode\n     * otherwise we'll use the unified mode.\n     * @param {String} testId\n     * @param {Object} [preselectedBackend] - the storage backend\n     * @returns {Promise<String>} resolves with the mode of the current test\n     */\n    var selectStoreMode = function selectStoreMode(testId, preselectedBackend) {\n      return store.getAll(function validate(storeName) {\n        return _.some(legacyPrefixes, function (prefix) {\n          return !_.isEmpty(storeName) && prefix + testId === storeName;\n        });\n      }, preselectedBackend).then(function (foundStores) {\n        if (_.isArray(foundStores) && foundStores.length > 0) {\n          return modes.fragmented;\n        }\n        return modes.unified;\n      });\n    };\n\n    /**\n     * Get the store for the given test\n     *\n     * @param {String} testId - unique test instance id\n     * @returns {testStore} a 'wrapped' store instance\n     * @param {Object} [preselectedBackend] - the storage backend (automatically selected by default)\n     * @throws {TypeError} without a testId\n     */\n    function testStoreLoader(testId, preselectedBackend) {\n      var storeNames = [];\n      var volatiles = [];\n      var changeTracking = {};\n      var testMode;\n\n      /**\n       * Is the test using a unified store mode ?\n       * @returns {Promise<Boolean>} true if unified\n       */\n      var isStoreModeUnified = function isStoreModeUnified() {\n        if (_.isUndefined(testMode)) {\n          return selectStoreMode(testId, preselectedBackend).then(function (result) {\n            if (result && typeof modes[result] !== 'undefined') {\n              testMode = result;\n            } else {\n              //use the unified mode by default\n              testMode = modes.unified;\n            }\n            logger.debug(`Test store mode ${result} for ${testId}`);\n            return result === modes.unified;\n          });\n        }\n        return Promise.resolve(testMode === modes.unified);\n      };\n      if (_.isEmpty(testId)) {\n        throw new TypeError('The store must be identified with a unique test identifier');\n      }\n\n      /**\n       * Wraps a store and add the support of \"volatile\" storages\n       * @typedef {Object} testStore\n       */\n      return {\n        /**\n         * Get a wrapped store instance, that let's you use multiple stores inside one store...\n         * (or in multiple stores if the test is in legacy mode)\n         * @param {String} storeName - the name of the sub store\n         * @returns {Promise<storage>}\n         */\n        getStore: function getStore(storeName) {\n          //call when the current storge has been changed\n          //only if the store is set to track changes\n          var trackChange = function trackChange() {\n            if (_.isBoolean(changeTracking[storeName])) {\n              changeTracking[storeName] = true;\n            }\n          };\n          if (_.isEmpty(storeName)) {\n            throw new TypeError('A store name must be provided to get the store');\n          }\n          if (!_.contains(storeNames, storeName)) {\n            storeNames.push(storeName);\n          }\n          return isStoreModeUnified().then(function (isUnified) {\n            var loadStore;\n            if (isUnified) {\n              loadStore = store(testId, preselectedBackend);\n            } else {\n              loadStore = store(`${storeName}-${testId}`, preselectedBackend);\n            }\n            return loadStore.then(function (loadedStore) {\n              var keyPattern = new RegExp(`^${storeName}__`);\n              var storeKey = function storeKey(key) {\n                return isUnified ? `${storeName}__${key}` : key;\n              };\n\n              /**\n               * The wrapped storage\n               * @type {Object}\n               */\n              return {\n                /**\n                 * Get an item with the given key\n                 * @param {String} key\n                 * @returns {Promise<*>} with the result in resolve, undefined if nothing\n                 */\n                getItem: function getItem(key) {\n                  return loadedStore.getItem(storeKey(key));\n                },\n                /**\n                 * Get all store items\n                 * @returns {Promise<Object>} with a collection of items\n                 */\n                getItems: function getItems() {\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      return _.transform(entries, function (acc, entry, key) {\n                        if (keyPattern.test(key)) {\n                          acc[key.replace(keyPattern, '')] = entry;\n                        }\n                        return acc;\n                      }, {});\n                    });\n                  } else {\n                    return loadedStore.getItems();\n                  }\n                },\n                /**\n                 * Set an item with the given key\n                 * @param {String} key - the item key\n                 * @param {*} value - the item value\n                 * @returns {Promise<Boolean>} with true in resolve if added/updated\n                 */\n                setItem: function setItem(key, value) {\n                  trackChange();\n                  return loadedStore.setItem(storeKey(key), value);\n                },\n                /**\n                 * Remove an item with the given key\n                 * @param {String} key - the item key\n                 * @returns {Promise<Boolean>} with true in resolve if removed\n                 */\n                removeItem: function removeItem(key) {\n                  trackChange();\n                  return loadedStore.removeItem(storeKey(key));\n                },\n                /**\n                 * Clear the current store\n                 * @returns {Promise<Boolean>} with true in resolve once cleared\n                 */\n                clear: function clear() {\n                  trackChange();\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      _.forEach(entries, function (entry, key) {\n                        if (keyPattern.test(key)) {\n                          loadedStore.removeItem(key);\n                        }\n                      });\n                    });\n                  } else {\n                    return loadedStore.clear();\n                  }\n                }\n              };\n            });\n          });\n        },\n        /**\n         * Define the given store as \"volatile\".\n         * It means the store data can be revoked\n         * if the user change browser for example\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {testStore} chains\n         */\n        setVolatile: function setVolatile(storeName) {\n          if (!_.contains(volatiles, storeName)) {\n            volatiles.push(storeName);\n          }\n          return this;\n        },\n        /**\n         * Check the given storeId. If different from the current stored identifier\n         * we initiate the invalidation of the volatile data.\n         * @param {String} storeId - the id to check\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileIfStoreChange: function clearVolatileIfStoreChange(storeId) {\n          var self = this;\n          var shouldClear = false;\n          return store.getIdentifier(preselectedBackend).then(function (savedStoreId) {\n            if (!_.isEmpty(storeId) && !_.isEmpty(savedStoreId) && savedStoreId !== storeId) {\n              logger.info(`Storage change detected (${savedStoreId} != ${storeId}) => volatiles data wipe out !`);\n              shouldClear = true;\n            }\n            return shouldClear;\n          }).then(function (clear) {\n            if (clear) {\n              return self.clearVolatileStores();\n            }\n            return false;\n          });\n        },\n        /**\n         * Clear the storages marked as volatile\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileStores: function clearVolatileStores() {\n          var self = this;\n          var clearing = volatiles.map(function (storeName) {\n            return self.getStore(storeName).then(function (storeInstance) {\n              return storeInstance.clear();\n            });\n          });\n          return Promise.all(clearing).then(function (results) {\n            return results && results.length === volatiles.length;\n          });\n        },\n        /**\n         * Observe changes on the given store\n         *\n         * @param {String} storeName - the name of the store to observe\n         * @returns {testStore} chains\n         */\n        startChangeTracking: function startChangeTracking(storeName) {\n          changeTracking[storeName] = false;\n          return this;\n        },\n        /**\n         * Has the store some changes\n         *\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {Boolean} true if the given store has some changes\n         */\n        hasChanges: function hasChanges(storeName) {\n          return changeTracking[storeName] === true;\n        },\n        /**\n         * Reset the change listening\n         *\n         * @param {String} storeName - the name of the store\n         * @returns {testStore} chains\n         */\n        resetChanges: function resetChanges(storeName) {\n          if (_.isBoolean(changeTracking[storeName])) {\n            changeTracking[storeName] = false;\n          }\n          return this;\n        },\n        /**\n         * Remove the whole store\n         * @returns {Promise<Boolean>} true if done\n         */\n        remove: function remove() {\n          var legacyStoreExp = new RegExp(`-${testId}$`);\n          return isStoreModeUnified().then(function (isUnified) {\n            if (isUnified) {\n              return store(testId, preselectedBackend).then(function (storeInstance) {\n                return storeInstance.removeStore();\n              });\n            }\n            return store.removeAll(function (storeName) {\n              return legacyStoreExp.test(storeName);\n            }, preselectedBackend);\n          });\n        },\n        /**\n         * Wraps the identifier retrieval\n         * @returns {Promise<String>} the current store id\n         */\n        getStorageIdentifier: function getStorageIdentifier() {\n          return store.getIdentifier(preselectedBackend);\n        }\n      };\n    }\n\n    return testStoreLoader;\n\n});\n\n","\ndefine(\"taoTests/loader/taoTestsRunner.bundle\", function(){});\n","define(\"taoTests/loader/taoTestsRunner.min\", [\"taoItems/loader/taoItems.min\"], function(){});\n"],"mappings":"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"}