{"version":3,"mappings":"AACAA,MCDA,+FAEAC,sEACAC,gIAoBAC,yBACA,UACA,aACA,UACA,SACA,QACA,CAYAC,gDAEA,iBAEA,GAEAJ,MC/CA,yDA0CA,6BACA,gBAIA,MAHAK,wCACAC,iBACA,GACAA,GACA,CAdA,+CAgBA,wBAEA,GAEAN,MCtDA,0FAEAC,sEACAM,kIAwBA,yCAEAC,qBACA,GAEA,aAEA,GAEAR,MCpCA,kJAiCA,sCAkDA,gCACAS,gCAEAC,wCACAC,cACAC,MACAC,eACAC,gBACAC,8BACAC,qCACA,EAEA,mCACAJ,gFAGAK,mBACA,QAGAC,eACAC,+BAGAlB,4CACA,gEACAmB,mDACA,EACA,CAEA,uCACAX,gCAEAY,wCACAV,cACAC,MACAC,eACAS,eACAR,gBACAC,8BACAC,qCACA,EAEA,mCACAJ,gFAGAK,mBACA,EAGAM,sCAEAC,MADAb,aAEAC,MACAE,gBACAC,8BACAC,qCACA,EACAS,2BACAD,gCACAV,gBACAQ,cACA,GAEAE,kCACAV,gBACAQ,aACAT,UACA,KACAD,gBACAA,kBAEA,mCACAA,+DAGAK,oBAEA,QAGAC,oBAIAjB,gDACA,gEACAmB,mDACA,GAEAnB,+CACA,gEACAmB,kDACA,IAXAM,mBAYA,IA/IAT,UAWAU,aATAC,UAEAC,SAEAC,kBAUAC,0BAEAC,WAMAC,uCACAN,cACAO,8BAGAd,uEAEA,MADAO,yBACAO,6BACA,EACA,EAMAC,qCACAR,iBACA,EAyGA,kFACA,gDA4KA,MArKAV,WAaAmB,wBAEA,2BACA,iDAGA,kDACA,gDAGA,GAEA,EAFAnC,gBACAoC,eACA,UACA,oEAGA,kBASA,GARApC,+DACAiB,uCAGAjB,6DACAiB,qCAGA,oDACA,yFAIAc,SACAb,0BAEA,MAKA,GAJAlB,qDACAiB,6BAGA,kDACA,kDAIAc,SACAN,mBAEA,CAGA,MADAE,oBACA,IACA,EAMAU,6BACA,2CACA,+BACA,EACA,EAMAC,+BACA,aACA,EAMAC,0BACAP,oCAEAF,gCAGA,MAFAF,mBACAC,2BACAW,8BACA,EACA,EACA,EAMAC,uBACA,qCACAT,oCACAF,gCACA,uDAEA,MADAF,UACAY,+CACAE,gBACA,EACA,EACA,EACA,EACA,EACA,EAMAC,uBACA,2CACA,0DACA3C,wBACA4B,iBACAC,2BAGA7B,+BAEA+B,UACA,EACA,EACA,EAOAa,qBAmBA,MAlBAb,YAEA/B,oCACAQ,gCAEAqC,gDACA1B,6BACA,EAEAnB,2CAEAA,0CAEAA,qCACA,GAEA4B,SACAC,kBACAG,oCACA,qDACA,EACA,CACA,EACAhB,QACA,CAjWAhB,sEACA8C,+FACAC,wFAoBAC,4BACAC,4BA4UA,2BAEA,GAEAlD,MCzWA,mLAuCA,yCAuEA,6BACA,kFACAyB,6BAGA,4BACAxB,+BAIA0C,6CAHAA,SAIA,CACA,CASA,2BACA,iBAQA,MANA1C,wCACAA,8BACAkD,gCAEA,GAEAjB,sBACA,CAQA,0BACAd,2BACA,IAzGAA,QAKAgC,WAXAC,0EACAC,sEAeAC,YAKAC,QACAC,QACAC,SACAC,UACAC,UACAC,UACA,EAKA,kBAKA,8DAMAzD,YAMA0D,MAMAC,cAMAC,UAmtBA,MAzpBA5C,oBAUAqC,OAcA,MAbAL,cACAA,iCAIAnD,0CACA,wDACAsD,gCACA,GAEAU,gMACA,sGACA,sBACA,IACA,EAUAN,SAIA,MAHAM,+DACA,4DACA,sBACA,IACA,EAWAC,kBAIA,MAHAD,iDACA,qKACA,sBACA,IACA,EAWAE,6BAIA,MAHAF,sDACA,4EACA,sBACA,IACA,EAUAG,oBAKA,MAJAH,6CACAI,sCACA,kCACA,sBACA,IACA,EASAC,qBAOA,MANA,wCACAL,6CACA,uEACA,sBAGA,IACA,EASAM,oBAOA,MANA,wCACAN,4CACA,sEACA,sBAGA,IACA,EASAL,SAIA,MAHAK,+DACA,4CACA,sBACA,IACA,EASAvB,QAIA,MAHAuB,6DACA,0CACA,sBACA,IACA,EASAJ,UAQA,MAPAI,iEACA,SACA,sBAEA,aACA,gFACA,sBACA,IACA,EAMAO,YACA,iBACA,EAWAC,aACA,mCACA,EAMAC,aACA,cACA,EAOAC,gBACA,oBACA,EAWAC,mBACA,oCACA,EAUAC,4BACA,oCACA,4CAEA,6BACA,gCAEA,CAEA,QACA,EAOAC,gBAKA,MAJA1E,cACAA,+CAGAA,UACA,EAOA2E,WACA,WACA,qCACA,iEAGAjB,oCACAA,qDACAA,mCACA,CAEA,YACA,EAOAkB,mBAKA,MAJA,2DACAjB,qDAGAA,aACA,EAOAkB,eAKA,MAJA,mDACAjB,6CAGAA,SACA,EASAkB,qBACA,4CAEAC,iDAIA,mCAHAjD,4GAIA,EAQAkD,eACA,oBACA,EAUAC,sBACA,sCACA,kDAIA,MADA7B,uBACA,IACA,EASA8B,yBACA,UAMA,MAJArF,6CACAsF,qDAGA,OACA,EAYAC,gCACA,WASA,MANAC,QADA,mCACAvD,4DAEA+B,gDAGAwB,0BACAA,MACA,EAWAC,2BACA,uCACA,wEAGA,wDACA,EAYAC,kCACA,uCACA,wEASA,MANAtB,2CACAuB,UACAlC,SACAmC,WACA,EACAxB,mCACA,IACA,EAOAyB,cACA,6CACA,EAQAC,sBAKA,MAJA3C,wCACAA,oCAGA,IACA,EAMA4C,iBACA,gDACA,EAOAC,4BAKA,MAJA7C,2CACAA,0CAGA,IACA,EAMA8C,aACA,4CACA,EAOAC,oBAKA,MAJA/C,uCACAA,kCAGA,IACA,EAMAgD,gBASA,MARAhD,cACAnD,sCACAmD,8CAEAA,gCAIAA,UACA,EAQAiD,kBACApG,6BACAgE,2BAIA,kCACA,KACA,EAQAqC,sBACArG,iCACAgE,+BAIA,sCACA,KACA,EASAsC,2BACAtG,6BACAgE,oCAIA,2CACA,KACA,EAUAuC,gCACAvG,6BACAgE,yCAIA,yCACA,KACA,EAQAwC,gBACAxG,6BACAgE,yBAIA,yBACA,KACA,EAOAyC,cACAzG,8BACA,uBAKAiC,mBAJA,0BACA+B,uBAOA,wBACA,2CAGA,KACA,EAOA0C,eACA1G,+BACA,wBACA,0BACAgE,uBAGA/B,mBAIA,6BACA,4CAGA,KACA,EAUA0E,+BACA3G,gCACAgE,wCAIA,wCACA,KACA,CAEA,GACA7C,4BACA,0BACA,6CACAgC,YACAA,mBAGAhD,gBACA0D,WACAC,mBACAC,cACA,GACA5C,MACA,CAvzBAnB,sEACA4G,mHACAC,iJACAC,sJAuzBA,kFAEA,0CACA,yFAGA,QACA,GAEA,aAEA,GAEA/G,MCz0BA,qPAsCA,wCAkBA,2BACA,oDAGA,MADAgH,oBACAC,YACA,CAQA,+BACA,gCAMA,MAJAC,mBACAC,mCAGAA,IACA,CAaA,4CAEA,oEACA,sBACAC,iCACA,CACA,GAGA,4CACAC,gCAEAC,iCACAA,mBAGAA,IACAC,aAEAzD,+CACAnB,uBAEA,EACA,EACA,CAWA,0BACA,aACA6E,eACAC,+BACA,QAEAC,oDAIAC,wDAKA,MAFAD,gBAEAE,0BACAC,iBACAjH,SACA,EACA,wBAEA,iCACAiH,eACAjH,SACA,EACA,GAlBAsB,qFAmBA,IAhHA4B,sDACAgE,eACAd,mBACAe,iDAEAC,4CAEAC,mCACAf,eACAQ,eACAQ,qCAsjBA,MAzcApE,mBAOAqE,6BACAtG,kDACAsF,4BASA,MARAD,yBAEAjH,8BACAA,kBACAkH,aAEA,GAEA,IACA,EASAiB,qCAKA,MAJAhF,cACA0E,2BAGAO,8BACA,EASA5E,2BAOA,oDACA,EAQAI,2BAKA,2CAIA,GAFA6D,eAEAY,oBACA,4CACA,+BACAC,kDACA,CAEAD,oBACAE,gBACAC,qBACA,GACAC,iBACAH,aACAE,sBAEA9F,SAEA,EACA,EAEA,EACA,EAMAyD,uCACA,qBACA,EAOAuC,+BAMA,MALA,oBACAT,gBACA,2BAGA,IACA,EAQAU,uCAMA,MALA,mBACAV,gBACA,mCAGA,IACA,EAMAW,6BACA,mBACA,EAMAC,+BACA,mBACA,EASAC,sDACA,2EACA,EAMAC,2CACA,mBACA,EAMAC,2CACA,2BACA,EAMAC,2CACA,oBAEAxB,cAIAY,sBACAA,yDACArI,6CACAsI,sDAEAA,aACAA,4CACAY,+BACAA,+BAEA,4BACAA,yBACA,mCACAA,iBACAA,+CACA,0BACA,2CACAxG,qBACA,gBACA,iBAEA4E,uDAGAA,+EAEA,IAGAe,qBAhCApG,qFAiCA,EASAkH,uCACA,qCACA,kDAGA,0BACA,+DAQA,MALA,4DACAC,0CACA,GACAX,cACA,mCACA,IACA,EAQAY,oCACA,kEACA,iDACA,EACA,EAQAC,yDAKA,MAJAtJ,0BACAA,gCAGA,IACA,EAUA6F,mCAKA,8BACA,EAOAE,yCAKA,iCACA,EAOAE,iCAKA,6BACA,EAUAsD,yDAKA,mDACA,EAWAC,+DAOA,mEACA,EAUAC,qCAMA,qCACA,EAYAC,0DAQA,kEACA,EAYAC,mEAQA,uEACA,EAWAC,gDAQA,8CACA,CACA,GAEAC,qCACAhG,0BACA,0BACAA,iBACA,GAEAA,6CACA,0CACA,uCACAiG,uCAEA9J,+CACA+J,YACAlG,iDAEAA,wCAEA,GAGAuC,MACA,GACA8B,oCACArE,yCACAA,4BACAiG,wCACAjG,kBAGAuC,MACA,GACAsB,4CACAtF,aACA4H,yCACA,gCACA,CACA,GACAnG,KACA,CAtmBA7D,sEACAoH,0FACA6C,8GACArD,mHACAC,iJACAqD,gKACAL,gIAmBAM,cACAC,gBA8kBAvG,qCAEA,YAEA,GAEA9D,MChnBA,wSA8CA,sCACAsK,qEACAC,gFASAC,uCACAC,2EACAC,8CAEA,uDACA,2FAGA,6FACAC,mFACAD,OACA,CACA,EAMAE,cACAxJ,SACA,8EACA,sDACA,EAEAyJ,aACA,kFACA,iGACAF,+EACAE,WACA,CACA,EAEAtC,eACA,oFACA,kEACA,EAEAzE,QACA,6EACA,oDACA,EAEAP,UACA,sEACA,2DACA,CAEA,EAMA,MAJAgH,iBACAO,uDAGA5I,sDACA,kDACA4I,2EACA,+GACA,iEACAA,sEACA,CACA,qBACA,EACA,CACA,CACAA,6FAEA,wFAEA,KADAA,qFACAxD,GACA,EACA,CA7HAyD,kIACAC,uIACAC,6HACA1C,6HACAnH,+FACA0C,0FACA+G,mHAmBA,qDAsGA,8BAEA,GAEA7K,MCrIA,2DA4BA,iBAMAyD,qBAEA,qCAGAd,SAEA,EACA,EAOAkB,2BAEA,qCAGAlB,SAEA,EACA,EAQAmD,mCAEA,qCAGAnD,SAEA,EACA,EAOAqD,yCAEA,qCAGArD,SAEA,EACA,EASA8G,yCAEA,qCAGA9G,SAEA,EACA,EASA+G,2BAEA,qCAGA/G,SAEA,EACA,EAWAgH,iCAEA,qCAGAhH,SAEA,EACA,EAUAiH,yCAEA,qCAGAjH,SAEA,EACA,EAWAkH,+BAEA,qCAGAlH,SAEA,EACA,CACA,EAEA,kBAEA,GAEA3C,MCzLA,+MAeA,mDACA,gCACA,gCACA,CA0BA,2CACA,qEACA,iEAEA,2BACA,+FAGA,2EACA,kIAGA,QACA,CASA,kCACAc,sEACAwC,iEAEA,0CACA,6BAGA,6CACA,2CAEA,0EACA,4CAGA,wDACA,iDAEA,CAEA,QACA,CAiBA,qCACA4H,uEACA5H,iEACA6H,mFACA/J,YACAmC,WAEA,cACA,0FAGA6H,wCAKA,iCAMAC,gBACA,gCACA,EAMAC,YACA,aACA,CAEA,8CAEA,6EACAC,2BACAhI,yBAGA,uBACA,WACA,wCACA,0BACA,oEACAiI,0BACA,GACAC,qFACAC,8CACAA,iEAGAA,IACA,4BACAtK,wFACAnB,aACA,qDACA,EACA,4DACA,2BACA,wCAEA,MADAmB,aACAuK,UACA,8BACA,yBACA,GACA,mCACA,CA1KA1L,sEACA2L,8GACAC,kIACAb,uIACAc,mHAEA,mFAKA,MAJA,kCACAC,+CAGA,0CACA,GAgKA,6BAEA,GAEA/L,MClLA,gHAgFA,uDAIAgM,UAHAC,cACAC,aACAC,kBAOAC,uDACAnM,yBACAoM,iEASA,MAPAL,UADAM,0CACAA,OAGAC,cAGAzB,wDACAwB,sBACA,GAGApK,yCACA,EAEA,qBACA,kFAQA,OAOAsK,sCAGA,uCACAvM,yCACAkM,6BAEA,EAEA,wBACA,sEAOA,MAJAlM,mCACAgM,2BAGAG,8CACA,cAQA,MALAK,WADAC,UACAC,iCAEAA,mDAGAF,wCACAG,0CAEAC,gCACA,2CACA,EAOA,OAMAnD,8BACA,yCACA,EAMAoD,mCACAJ,WACAvH,8CACA,mDAKA,MAJAyH,wBACAlB,uCAGAA,GACA,KACA,GAEAvG,sBAEA,EAQA4H,oCAEA,MADAC,eACA7H,wCACA,EAOA8H,oCAEA,MADAD,eACA7H,qCACA,EAMA+H,6BACAF,eAEAN,UACAvH,8CACAlF,sCACA2M,sBACAzH,2BAEA,EACA,GAEAA,mBAEA,CACA,CACA,EACA,EACA,EASAgI,4CAKA,MAJAlN,kCACAiM,0BAGA,IACA,EAQAkB,2EACAjE,WACAkE,eACA,2EAMA,MALApN,uEACA6K,oGACAuC,gBAGAA,WACA,gCACAH,OACA/D,0BAIA,EACA,EAMAmE,sDACAnE,WACAoE,2CACA,6DACA,4BACA,EACA,GACA,oDACA,iDACA,EACA,EAQAC,4DAEA,MADArB,8BACA,IACA,EAQAsB,0CACA,oCACA,EAQAC,8CAKA,MAJAzN,0CACAkM,8BAGA,IACA,EAMAwB,yBACA,6CACA,2DACAjB,WACAC,8DACA,kCACA,GAGAA,oCACA,qCACA,qBACA,EACA,EAMAiB,qDACA,8CACA,CACA,CACA,CAjWA3N,sEACA0M,0FACA5B,qIAyBAD,8DAQA+C,8DAKAtB,OACAuB,kBAEAC,uBAEA,EAUA1B,oEACA,iDACA,8CACA,sDACA,EACA,uDACApM,8CACAsM,iBAGAA,aACA,EACA,EAgSA,sBAEA,GCtWAvM,6DACAA,MCFA","names":["define","_","areaBroker$1","requireAreas","areaBroker","defaultObjects","map","pluginFactory","hostName","eventNs","probeHandler","now","data","id","type","timestamp","timezone","overseer","probe","collectLatencyEvent","runner","startHandler","marker","stopHandler","last","args","collectEvent","queueStorage","probes","queue","immutableQueue","writing","started","getStorage","Promise","resetStorage","add","name","getQueue","getProbes","push","storage","flush","resolve","start","stop","removeHandler","moment","uuid","timeZone","slice","execStack","dataHolder","pluginFactories","config","plugins","states","init","ready","render","finish","destroy","proxy","probeOverseer","testStore","providerRun","loadItem","renderItem","unloadItem","itemStates","disableItem","enableItem","getConfig","getOptions","getPlugins","getPlugin","getPluginsConfig","getPluginConfig","getAreaBroker","getProxy","getProbeOverseer","getTestStore","getPluginStore","loadedStore","getState","setState","getPersistentState","state","setPersistentState","stored","getItemState","setItemState","loaded","disabled","getTestData","setTestData","getTestContext","setTestContext","getTestMap","setTestMap","getDataHolder","next","previous","jump","skip","exit","pause","resume","timeout","eventifier","providerRegistry","dataHolderFactory","extraCallParams","mergedParams","middlewares","list","middleware","async","err","reject","command","params","initialized","delegateProxy","applyMiddlewares","status","testDataHolder","proxyAdapter","initConfig","tokenHandler","onlineStatus","use","install","delegate","communicatorPromise","communicator","then","destroyCommunicator","catch","setOnline","setOffline","isOnline","isOffline","isConnectivityError","getTokenHandler","hasCommunicator","getCommunicator","self","channel","communicatorInstance","send","addCallActionParams","sendVariables","callTestAction","getItem","submitItem","callItemAction","telemetry","connectivity","response","msg","wrapper","delegator","tokenHandlerFactory","_defaults","_slice","providers","loadFromBundle","loadAndRegisterProvider","providersToLoad","target","loadedProviders","registration","itemRunner","logger","loggerFactory","providerLoader","pluginLoader","container","template","validateTestRunnerConfiguration","getOption","getRunner","results","renderTo","runnerConfig","acc","destroying","component","runnerFactory","Handlebars","helpers","testMode","storeNames","volatiles","changeTracking","isStoreModeUnified","selectStoreMode","result","modes","getStore","loadStore","isUnified","store","keyPattern","storeKey","getItems","setItem","trackChange","removeItem","clear","setVolatile","clearVolatileIfStoreChange","shouldClear","clearVolatileStores","clearing","startChangeTracking","hasChanges","resetChanges","remove","getStorageIdentifier","legacyPrefixes","unified","fragmented"],"sources":["/home/alberto/workspace/oat/taocloud-ami-luoss/tao/views/build/config-wrap-start-default.js","../runner/areaBroker.js","../runner/dataHolder.js","../runner/plugin.js","../runner/probeOverseer.js","../runner/runner.js","../runner/proxy.js","../runner/providerLoader.js","../runner/proxy/sample.js","../runner/runnerComponent.js","../runner/testStore.js","module-create.js","/home/alberto/workspace/oat/taocloud-ami-luoss/tao/views/build/config-wrap-end-default.js"],"sourcesContent":["\n","define('taoTests/runner/areaBroker',['lodash', 'ui/areaBroker'], function (_, areaBroker$1) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    areaBroker$1 = areaBroker$1 && Object.prototype.hasOwnProperty.call(areaBroker$1, 'default') ? areaBroker$1['default'] : areaBroker$1;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var requireAreas = ['content', //where the content is renderer, for example an item\n    'toolbox', //the place to add arbitrary tools, like a zoom, a comment box, etc.\n    'navigation', //the navigation controls like next, previous, skip\n    'control', //the control center of the test, progress, timers, etc.\n    'header', //the area that could contains the test titles\n    'panel' //a panel to add more advanced GUI (item review, navigation pane, etc.)\n    ];\n    /**\n     * Creates an area broker with the required areas for the test runner.\n     *\n     * @see ui/areaBroker\n     *\n     * @param {jQueryElement|HTMLElement|String} $container - the main container\n     * @param {Object} mapping - keys are the area names, values are jQueryElement\n     * @returns {broker} the broker\n     * @throws {TypeError} without a valid container\n     */\n\n    var areaBroker = _.partial(areaBroker$1, requireAreas);\n\n    return areaBroker;\n\n});\n\n","define('taoTests/runner/dataHolder',[],function () { 'use strict';\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n\n    /**\n     * Holds the test runner data.\n     *\n     * @example\n     * var holder = holder();\n     * holder.get('testMap');\n     *\n     * @author Bertrand Chevrier <bertrand@taotesting.com>\n     */\n\n    /**\n     * @type {String[]} the list of default objects to create\n     */\n    const defaultObjects = ['testContext', 'testMap'];\n    /**\n     * Creates a new data holder,\n     * with default entries.\n     *\n     * @returns {Map} the holder\n     */\n\n    function dataHolderFactory() {\n      var map = new Map();\n      defaultObjects.forEach(function (entry) {\n        map.set(entry, {});\n      });\n      return map;\n    }\n\n    return dataHolderFactory;\n\n});\n\n","define('taoTests/runner/plugin',['lodash', 'core/plugin'], function (_, pluginFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    pluginFactory = pluginFactory && Object.prototype.hasOwnProperty.call(pluginFactory, 'default') ? pluginFactory['default'] : pluginFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * A pluginFactory configured for the test runner\n     * @returns {Function} the preconfigured plugin factory\n     */\n\n    var plugin = _.partialRight(pluginFactory, {\n      //alias getHost to getTestRunner\n      hostName: 'testRunner'\n    });\n\n    return plugin;\n\n});\n\n","define('taoTests/runner/probeOverseer',['lodash', 'moment', 'lib/uuid', 'lib/moment-timezone.min'], function (_, moment, uuid, momentTimezone_min) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    moment = moment && Object.prototype.hasOwnProperty.call(moment, 'default') ? moment['default'] : moment;\n    uuid = uuid && Object.prototype.hasOwnProperty.call(uuid, 'default') ? uuid['default'] : uuid;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var timeZone = moment.tz.guess();\n    var slice = Array.prototype.slice;\n    /**\n     * Create the overseer intance\n     * @param {runner} runner - a instance of a test runner\n     * @returns {probeOverseer} the new probe overseer\n     * @throws TypeError if something goes wrong\n     */\n\n    function probeOverseerFactory(runner) {\n      // the created instance\n      var overseer; // the list of registered probes\n\n      var probes = []; //temp queue\n\n      var queue = []; //immutable queue which will not be flushed\n\n      var immutableQueue = [];\n      /**\n       * @type {Storage} to store the collected events\n       */\n\n      var queueStorage;\n      /**\n       * @type {Promise} Promises chain to avoid write collisions\n       */\n\n      var writing = Promise.resolve(); //is the overseer started\n\n      var started = false;\n      /**\n       * Get the storage instance\n       * @returns {Promise} that resolves with the storage\n       */\n\n      var getStorage = function getStorage() {\n        if (queueStorage) {\n          return Promise.resolve(queueStorage);\n        }\n\n        return runner.getTestStore().getStore('test-probe').then(function (newStorage) {\n          queueStorage = newStorage;\n          return Promise.resolve(queueStorage);\n        });\n      };\n      /**\n       * Unset the storage instance\n       */\n\n\n      var resetStorage = function resetStorage() {\n        queueStorage = null;\n      };\n      /**\n       * Register the collection event of a probe against a runner\n       * @param {Object} probe - a valid probe\n       */\n\n\n      function collectEvent(probe) {\n        var eventNs = `.probe-${probe.name}`; //event handler registered to collect data\n\n        var probeHandler = function probeHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n\n          overseer.push(data);\n        }; //fallback\n\n\n        if (probe.latency) {\n          return collectLatencyEvent(probe);\n        }\n\n        _.forEach(probe.events, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(probeHandler, eventName));\n        });\n      }\n\n      function collectLatencyEvent(probe) {\n        var eventNs = `.probe-${probe.name}`; //start event handler registered to collect data\n\n        var startHandler = function startHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            marker: 'start',\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n\n          overseer.push(data);\n        }; //stop event handler registered to collect data\n\n\n        var stopHandler = function stopHandler() {\n          var now = moment();\n          var last;\n          var data = {\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n          var args = slice.call(arguments);\n          last = _.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'start'\n          });\n\n          if (last && !_.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'end',\n            id: last.id\n          })) {\n            data.id = last.id;\n            data.marker = 'end';\n\n            if (typeof probe.capture === 'function') {\n              data.context = probe.capture.apply(probe, [runner].concat(args));\n            }\n\n            overseer.push(data);\n          }\n        }; //fallback\n\n\n        if (!probe.latency) {\n          return collectEvent(probe);\n        }\n\n        _.forEach(probe.startEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(startHandler, eventName));\n        });\n\n        _.forEach(probe.stopEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(stopHandler, eventName));\n        });\n      } //argument validation\n\n\n      if (!_.isPlainObject(runner) || !_.isFunction(runner.init) || !_.isFunction(runner.on)) {\n        throw new TypeError('Please set a test runner');\n      }\n      /**\n       * @typedef {probeOverseer}\n       */\n\n\n      overseer = {\n        /**\n         * Add a new probe\n         * @param {Object} probe\n         * @param {String} probe.name - the probe name\n         * @param {Boolean} [probe.latency = false] - simple or latency mode\n         * @param {String[]} [probe.events] - the list of events to listen (simple mode)\n         * @param {String[]} [probe.startEvents] - the list of events to mark the start (lantency mode)\n         * @param {String[]} [probe.stopEvents] - the list of events to mark the end (latency mode)\n         * @param {Function} [probe.capture] - lambda fn to define the data context, it receive the test runner and the event parameters\n         * @returns {probeOverseer} chains\n         * @throws TypeError if the probe is not well formatted\n         */\n        add: function add(probe) {\n          // probe structure strict validation\n          if (!_.isPlainObject(probe)) {\n            throw new TypeError('A probe is a plain object');\n          }\n\n          if (!_.isString(probe.name) || _.isEmpty(probe.name)) {\n            throw new TypeError('A probe must have a name');\n          }\n\n          if (_.where(probes, {\n            name: probe.name\n          }).length > 0) {\n            throw new TypeError('A probe with this name is already regsitered');\n          }\n\n          if (probe.latency) {\n            if (_.isString(probe.startEvents) && !_.isEmpty(probe.startEvents)) {\n              probe.startEvents = [probe.startEvents];\n            }\n\n            if (_.isString(probe.stopEvents) && !_.isEmpty(probe.stopEvents)) {\n              probe.stopEvents = [probe.stopEvents];\n            }\n\n            if (!probe.startEvents.length || !probe.stopEvents.length) {\n              throw new TypeError('Latency based probes must have startEvents and stopEvents defined');\n            } //if already started we register the events on addition\n\n\n            if (started) {\n              collectLatencyEvent(probe);\n            }\n          } else {\n            if (_.isString(probe.events) && !_.isEmpty(probe.events)) {\n              probe.events = [probe.events];\n            }\n\n            if (!_.isArray(probe.events) || probe.events.length === 0) {\n              throw new TypeError('A probe must define events');\n            } //if already started we register the events on addition\n\n\n            if (started) {\n              collectEvent(probe);\n            }\n          }\n\n          probes.push(probe);\n          return this;\n        },\n\n        /**\n         * Get the time entries queue\n         * @returns {Promise} with the data in parameterj\n         */\n        getQueue: function getQueue() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue');\n          });\n        },\n\n        /**\n         * Get the list of defined probes\n         * @returns {Object[]} the probes collection\n         */\n        getProbes: function getProbes() {\n          return probes;\n        },\n\n        /**\n         * Push a time entry to the queue\n         * @param {Object} entry - the time entry\n         */\n        push: function push(entry) {\n          getStorage().then(function (storage) {\n            //ensure the queue is pushed to the store consistently and atomically\n            writing = writing.then(function () {\n              queue.push(entry);\n              immutableQueue.push(entry);\n              return storage.setItem('queue', queue);\n            });\n          });\n        },\n\n        /**\n         * Flush the queue and get the entries\n         * @returns {Promise} with the data in parameter\n         */\n        flush: function flush() {\n          return new Promise(function (resolve) {\n            getStorage().then(function (storage) {\n              writing = writing.then(function () {\n                return storage.getItem('queue').then(function (flushed) {\n                  queue = [];\n                  return storage.setItem('queue', queue).then(function () {\n                    resolve(flushed);\n                  });\n                });\n              });\n            });\n          });\n        },\n\n        /**\n         * Start the probes\n         * @returns {Promise} once started\n         */\n        start: function start() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue').then(function (savedQueue) {\n              if (_.isArray(savedQueue)) {\n                queue = savedQueue;\n                immutableQueue = savedQueue;\n              }\n\n              _.forEach(probes, collectEvent);\n\n              started = true;\n            });\n          });\n        },\n\n        /**\n         * Stop the probes\n         * Be carefull, stop will also clear the store and the queue\n         * @returns {Promise} once stopped\n         */\n        stop: function stop() {\n          started = false;\n\n          _.forEach(probes, function (probe) {\n            var eventNs = `.probe-${probe.name}`;\n\n            var removeHandler = function removeHandler(eventName) {\n              runner.off(eventName + eventNs);\n            };\n\n            _.forEach(probe.startEvents, removeHandler);\n\n            _.forEach(probe.stopEvents, removeHandler);\n\n            _.forEach(probe.events, removeHandler);\n          });\n\n          queue = [];\n          immutableQueue = [];\n          return getStorage().then(function (storage) {\n            return storage.removeItem('queue').then(resetStorage);\n          });\n        }\n      };\n      return overseer;\n    }\n\n    return probeOverseerFactory;\n\n});\n\n","define('taoTests/runner/runner',['lodash', 'core/eventifier', 'core/providerRegistry', 'taoTests/runner/dataHolder'], function (_, eventifier, providerRegistry, dataHolderFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    dataHolderFactory = dataHolderFactory && Object.prototype.hasOwnProperty.call(dataHolderFactory, 'default') ? dataHolderFactory['default'] : dataHolderFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2020 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * Builds an instance of the QTI test runner\n     *\n     * @param {String} providerName\n     * @param {Function[]} pluginFactories\n     * @param {Object} config\n     * @param {String} config.serviceCallId - the identifier of the test session\n     * @param {String} [config.testDefinition] - the identifier of the test definition\n     * @param {String} [config.testCompilation] - the identifier of the compiled test\n     * @param {Object} config.options - the test runner configuration options\n     * @param {Object} config.options.plugins - the plugins configuration\n     * @param {jQueryElement} [config.renderTo] - the dom element that is going to holds the test content (item, rubick, etc)\n     * @returns {runner}\n     */\n\n    function testRunnerFactory(providerName) {\n      let pluginFactories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      /**\n       * @type {Object} The test runner instance\n       */\n      let runner;\n      /**\n       * @type {Map} Contains the test runner data\n       */\n\n      let dataHolder;\n      /**\n       * @type {Object} the registered plugins\n       */\n\n      const plugins = {};\n      /**\n       * @type {Object} the test of the runner\n       */\n\n      const states = {\n        init: false,\n        ready: false,\n        render: false,\n        finish: false,\n        destroy: false\n      };\n      /**\n       * @type {Object} keeps the states of the items\n       */\n\n      let itemStates = {};\n      /**\n       * The selected test runner provider\n       */\n\n      const provider = testRunnerFactory.getProvider(providerName);\n      /**\n       * Keep the area broker instance\n       * @see taoTests/runner/areaBroker\n       */\n\n      let areaBroker;\n      /**\n       * Keep the proxy instance\n       * @see taoTests/runner/proxy\n       */\n\n      let proxy;\n      /**\n       * Keep the instance of the probes overseer\n       * @see taoTests/runner/probeOverseer\n       */\n\n      let probeOverseer;\n      /**\n       * Keep the instance of a testStore\n       * @see taoTests/runner/testStore\n       */\n\n      let testStore;\n      /**\n       * Run a method of the provider (by delegation)\n       *\n       * @param {String} method - the method to run\n       * @param {...} args - rest parameters given to the provider method\n       * @returns {Promise} so provider can do async stuffs\n       */\n\n      function providerRun(method) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return new Promise(resolve => {\n          if (!_.isFunction(provider[method])) {\n            return resolve();\n          }\n\n          return resolve(provider[method].apply(runner, args));\n        });\n      }\n      /**\n       * Run a method in all plugins\n       *\n       * @param {String} method - the method to run\n       * @returns {Promise} once that resolve when all plugins are done\n       */\n\n\n      function pluginRun(method) {\n        var execStack = [];\n\n        _.forEach(runner.getPlugins(), plugin => {\n          if (_.isFunction(plugin[method])) {\n            execStack.push(plugin[method]());\n          }\n        });\n\n        return Promise.all(execStack);\n      }\n      /**\n       * Trigger error event\n       * @param {Error|String} err - the error\n       * @fires runner#error\n       */\n\n\n      function reportError(err) {\n        runner.trigger('error', err);\n      }\n      /**\n       * Defines the test runner\n       *\n       * @type {runner}\n       */\n\n\n      runner = eventifier({\n        /**\n         * Initialize the runner\n         *  - instantiate the plugins\n         *  - provider init\n         *  - plugins init\n         *  - call render\n         * @fires runner#init\n         * @returns {runner} chains\n         */\n        init() {\n          if (!dataHolder) {\n            dataHolder = this.getDataHolder();\n          } //instantiate the plugins first\n\n\n          _.forEach(pluginFactories, pluginFactory => {\n            const plugin = pluginFactory(runner, this.getAreaBroker());\n            plugins[plugin.getName()] = plugin;\n          });\n\n          providerRun('install').then(_.partial(providerRun, 'loadPersistentStates')).then(_.partial(pluginRun, 'install')).then(_.partial(providerRun, 'init')).then(_.partial(pluginRun, 'init')).then(() => {\n            this.setState('init', true).off('init.internal').after('init.internal', () => this.render()).trigger('init');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Render the runner\n         *  - provider render\n         *  - plugins render\n         * @fires runner#render\n         * @fires runner#ready\n         * @returns {runner} chains\n         */\n        render() {\n          providerRun('render').then(() => pluginRun('render')).then(() => {\n            this.setState('ready', true).trigger('render').trigger('ready');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Load an item\n         *  - provider loadItem, resolve or return the itemData\n         *  - plugins loadItem\n         *  - call renderItem\n         * @param {*} itemRef - something that let you identify the item to load\n         * @fires runner#loaditem\n         * @returns {runner} chains\n         */\n        loadItem(itemRef) {\n          providerRun('loadItem', itemRef).then(itemData => {\n            this.setItemState(itemRef, 'loaded', true).off('loaditem.internal').after('loaditem.internal', () => this.renderItem(itemRef, itemData)).trigger('loaditem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Render an item\n         *  - provider renderItem\n         *  - plugins renderItem\n         * @param {Object} itemRef\n         * @param {Object} itemData - the loaded item data\n         * @fires runner#renderitem\n         * @returns {runner} chains\n         */\n        renderItem(itemRef, itemData) {\n          providerRun('renderItem', itemRef, itemData).then(() => {\n            this.setItemState(itemRef, 'ready', true).trigger('renderitem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Unload an item (for example to destroy the item)\n         *  - provider unloadItem\n         *  - plugins unloadItem\n         * @param {*} itemRef - something that let you identify the item to unload\n         * @fires runner#unloaditem\n         * @returns {runner} chains\n         */\n        unloadItem(itemRef) {\n          providerRun('unloadItem', itemRef).then(() => {\n            itemStates = _.omit(itemStates, itemRef);\n            this.trigger('unloaditem', itemRef);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Disable an item\n         *  - provider disableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        disableItem(itemRef) {\n          if (!this.getItemState(itemRef, 'disabled')) {\n            providerRun('disableItem', itemRef).then(() => {\n              this.setItemState(itemRef, 'disabled', true).trigger('disableitem', itemRef);\n            }).catch(reportError);\n          }\n\n          return this;\n        },\n\n        /**\n         * Enable an item\n         *  - provider enableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        enableItem(itemRef) {\n          if (this.getItemState(itemRef, 'disabled')) {\n            providerRun('enableItem', itemRef).then(() => {\n              this.setItemState(itemRef, 'disabled', false).trigger('enableitem', itemRef);\n            }).catch(reportError);\n          }\n\n          return this;\n        },\n\n        /**\n         * When the test is terminated\n         *  - provider finish\n         *  - plugins finsh\n         * @fires runner#finish\n         * @returns {runner} chains\n         */\n        finish() {\n          providerRun('finish').then(() => pluginRun('finish')).then(() => {\n            this.setState('finish', true).trigger('finish');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Flushes the runner\n         *  - provider flush\n         *  - plugins flush\n         * @fires runner#flush\n         * @returns {runner} chains\n         */\n        flush() {\n          providerRun('flush').then(() => pluginRun('flush')).then(() => {\n            this.setState('flush', true).trigger('flush');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Destroy\n         *  - provider destroy\n         *  - plugins destroy\n         * @fires runner#destroy\n         * @returns {runner} chains\n         */\n        destroy() {\n          providerRun('destroy').then(() => pluginRun('destroy')).then(() => {\n            if (proxy) {\n              return proxy.destroy();\n            }\n          }).then(() => {\n            this.setTestContext({}).setTestMap({}).setState('destroy', true).trigger('destroy');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Get the whole test runner configuration\n         * @returns {Object} the config\n         */\n        getConfig() {\n          return config || {};\n        },\n\n        /**\n         * Get the options from the configuration parameters, (feature flags, parameter values, etc.)\n         *\n         * Alias to getConfig().options\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getOptions() {\n          return this.getConfig().options || {};\n        },\n\n        /**\n         * Get the runner pugins\n         * @returns {plugin[]} the plugins\n         */\n        getPlugins() {\n          return plugins;\n        },\n\n        /**\n         * Get a plugin\n         * @param {String} name - the plugin name\n         * @returns {plugin} the plugin\n         */\n        getPlugin(name) {\n          return plugins[name];\n        },\n\n        /**\n         * Get the configuration of the plugins\n         *\n         * Alias to getConfig().options.plugins\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getPluginsConfig() {\n          return this.getOptions().plugins || {};\n        },\n\n        /**\n         * Get the configuration of a given plugin\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @param {String} pluginName - the name of the plugin\n         * @returns {Object} the configuration options of the plugin\n         */\n        getPluginConfig(pluginName) {\n          if (pluginName && plugins[pluginName]) {\n            const pluginsConfig = this.getPluginsConfig();\n\n            if (pluginsConfig[pluginName]) {\n              return pluginsConfig[pluginName];\n            }\n          }\n\n          return {};\n        },\n\n        /**\n         * Get the area broker, load it if not present\n         *\n         * @returns {areaBroker} the areaBroker\n         */\n        getAreaBroker() {\n          if (!areaBroker) {\n            areaBroker = provider.loadAreaBroker.call(this);\n          }\n\n          return areaBroker;\n        },\n\n        /**\n         * Get the proxy, load it if not present\n         *\n         * @returns {proxy} the proxy\n         */\n        getProxy() {\n          if (!proxy) {\n            if (!_.isFunction(provider.loadProxy)) {\n              throw new Error('The provider does not have a loadProxy method');\n            }\n\n            proxy = provider.loadProxy.call(this);\n            proxy.on('error', error => this.trigger('error', error));\n            proxy.install(this.getDataHolder());\n          }\n\n          return proxy;\n        },\n\n        /**\n         * Get the probeOverseer, and load it if not present\n         *\n         * @returns {probeOverseer} the probe overseer\n         */\n        getProbeOverseer() {\n          if (!probeOverseer && _.isFunction(provider.loadProbeOverseer)) {\n            probeOverseer = provider.loadProbeOverseer.call(this);\n          }\n\n          return probeOverseer;\n        },\n\n        /**\n         * Get the testStore, and load it if not present\n         *\n         * @returns {testStore} the testStore instance\n         */\n        getTestStore() {\n          if (!testStore && _.isFunction(provider.loadTestStore)) {\n            testStore = provider.loadTestStore.call(this);\n          }\n\n          return testStore;\n        },\n\n        /**\n         * Get a plugin store.\n         * It's a convenience method that calls testStore.getStore\n         * @param {String} name - the name of store, usually the plugin name.\n         *\n         * @returns {Promise<storage>} the plugin store\n         */\n        getPluginStore(name) {\n          const loadedStore = this.getTestStore();\n\n          if (!loadedStore || !_.isFunction(loadedStore.getStore)) {\n            return Promise.reject(new Error('Please configure a testStore via loadTestStore to be able to get a plugin store'));\n          }\n\n          return this.getTestStore().getStore(name);\n        },\n\n        /**\n         * Check a runner state\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getState(name) {\n          return !!states[name];\n        },\n\n        /**\n         * Define a runner state\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         * @throws {TypeError} if the state name is not a valid string\n         */\n        setState(name, active) {\n          if (!_.isString(name) || _.isEmpty(name)) {\n            throw new TypeError('The state must have a name');\n          }\n\n          states[name] = !!active;\n          return this;\n        },\n\n        /**\n         * Checks a runner persistent state\n         *  - provider getPersistentState\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getPersistentState(name) {\n          let state;\n\n          if (_.isFunction(provider.getPersistentState)) {\n            state = provider.getPersistentState.call(runner, name);\n          }\n\n          return !!state;\n        },\n\n        /**\n         * Defines a runner persistent state\n         *  - provider setPersistentState\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {Promise} Returns a promise that:\n         *                      - will be resolved once the state is fully stored\n         *                      - will be rejected if any error occurs or if the state name is not a valid string\n         */\n        setPersistentState(name, active) {\n          let stored;\n\n          if (!_.isString(name) || _.isEmpty(name)) {\n            stored = Promise.reject(new TypeError('The state must have a name'));\n          } else {\n            stored = providerRun('setPersistentState', name, !!active);\n          }\n\n          stored.catch(reportError);\n          return stored;\n        },\n\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        getItemState(itemRef, name) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n\n          return !!(itemStates[itemRef] && itemStates[itemRef][name]);\n        },\n\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        setItemState(itemRef, name, active) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n\n          itemStates[itemRef] = itemStates[itemRef] || {\n            loaded: false,\n            ready: false,\n            disabled: false\n          };\n          itemStates[itemRef][name] = !!active;\n          return this;\n        },\n\n        /**\n         * Get the test data/definition\n         * @deprecated\n         * @returns {Object} the test data\n         */\n        getTestData() {\n          return dataHolder && dataHolder.get('testData');\n        },\n\n        /**\n         * Set the test data/definition\n         * @deprecated\n         * @param {Object} testData - the test data\n         * @returns {runner} chains\n         */\n        setTestData(testData) {\n          if (dataHolder && _.isPlainObject(testData)) {\n            dataHolder.set('testData', testData);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the test context/state\n         * @returns {Object} the test context\n         */\n        getTestContext() {\n          return dataHolder && dataHolder.get('testContext');\n        },\n\n        /**\n         * Set the test context/state\n         * @param {Object} testContext - the context to set\n         * @returns {runner} chains\n         */\n        setTestContext(testContext) {\n          if (dataHolder && _.isPlainObject(testContext)) {\n            dataHolder.set('testContext', testContext);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the test items map\n         * @returns {Object} the test map\n         */\n        getTestMap() {\n          return dataHolder && dataHolder.get('testMap');\n        },\n\n        /**\n         * Set the test items map\n         * @param {Object} testMap - the map to set\n         * @returns {runner} chains\n         */\n        setTestMap(testMap) {\n          if (dataHolder && _.isPlainObject(testMap)) {\n            dataHolder.set('testMap', testMap);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the data holder\n         * @returns {dataHolder}\n         */\n        getDataHolder() {\n          if (!dataHolder) {\n            if (_.isFunction(provider.loadDataHolder)) {\n              dataHolder = provider.loadDataHolder.call(this);\n            } else {\n              dataHolder = dataHolderFactory();\n            }\n          }\n\n          return dataHolder;\n        },\n\n        /**\n         * Move next alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        next(scope) {\n          if (_.isFunction(provider.next)) {\n            return providerRun('next', scope);\n          } //backward compat\n\n\n          this.trigger('move', 'next', scope);\n          return this;\n        },\n\n        /**\n         * Move previous alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        previous(scope) {\n          if (_.isFunction(provider.previous)) {\n            return providerRun('previous', scope);\n          } //backward compat\n\n\n          this.trigger('move', 'previous', scope);\n          return this;\n        },\n\n        /**\n         * Move to alias\n         * @param {String|Number} position - where to jump\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        jump(position, scope) {\n          if (_.isFunction(provider.jump)) {\n            return providerRun('jump', position, scope);\n          } //backward compat\n\n\n          this.trigger('move', 'jump', scope, position);\n          return this;\n        },\n\n        /**\n         * Skip alias\n         * @param {String|*} [scope] - the movement scope\n         * @param {String|*} [direction] - next/previous/jump\n         * @param {Number|*} [ref] - the item ref\n         * @fires runner#skip\n         * @returns {runner} chains\n         */\n        skip(scope, direction, ref) {\n          if (_.isFunction(provider.skip)) {\n            return providerRun('skip', scope, direction, ref);\n          } //backward compat\n\n\n          this.trigger('skip', scope, direction, ref);\n          return this;\n        },\n\n        /**\n         * Exit the test\n         * @param {String|*} [why] - reason the test is exited\n         * @fires runner#exit\n         * @returns {runner} chains\n         */\n        exit(why) {\n          if (_.isFunction(provider.exit)) {\n            return providerRun('exit', why);\n          } //backward compat\n\n\n          this.trigger('exit', why);\n          return this;\n        },\n\n        /**\n         * Pause the current execution\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        pause() {\n          if (_.isFunction(provider.pause)) {\n            if (!this.getState('pause')) {\n              this.setState('pause', true);\n              return providerRun('pause');\n            }\n\n            return Promise.resolve();\n          } //backward compat\n\n\n          if (!this.getState('pause')) {\n            this.setState('pause', true).trigger('pause');\n          }\n\n          return this;\n        },\n\n        /**\n         * Resume a paused test\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        resume() {\n          if (_.isFunction(provider.resume)) {\n            if (this.getState('pause')) {\n              this.setState('pause', false);\n              return providerRun('resume');\n            }\n\n            return Promise.resolve();\n          } //backward compat\n\n\n          if (this.getState('pause') === true) {\n            this.setState('pause', false).trigger('resume');\n          }\n\n          return this;\n        },\n\n        /**\n         * Notify a test timeout\n         * @param {String} scope - The scope where the timeout occurred\n         * @param {String} ref - The reference to the place where the timeout occurred\n         * @param {Object} [timer] - The timer's descriptor, if any\n         * @fires runner#timeout\n         * @returns {runner} chains\n         */\n        timeout(scope, ref, timer) {\n          if (_.isFunction(provider.timeout)) {\n            return providerRun('timeout', scope, ref, timer);\n          } //backward compat\n\n\n          this.trigger('timeout', scope, ref, timer);\n          return this;\n        }\n\n      });\n      runner.on('move', function () {\n        this.trigger(...arguments);\n      }).after('destroy', function destroyCleanUp() {\n        if (dataHolder) {\n          dataHolder.clear();\n        }\n\n        areaBroker = null;\n        proxy = null;\n        probeOverseer = null;\n        testStore = null;\n      });\n      return runner;\n    } //bind the provider registration capabilities to the testRunnerFactory\n\n\n    var runner = providerRegistry(testRunnerFactory, function validateProvider(provider) {\n      //mandatory methods\n      if (!_.isFunction(provider.loadAreaBroker)) {\n        throw new TypeError('The runner provider MUST have a method that returns an areaBroker');\n      }\n\n      return true;\n    });\n\n    return runner;\n\n});\n\n","define('taoTests/runner/proxy',['lodash', 'async', 'core/delegator', 'core/eventifier', 'core/providerRegistry', 'core/tokenHandler', 'core/connectivity'], function (_, async, delegator, eventifier, providerRegistry, tokenHandlerFactory, connectivity) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    async = async && Object.prototype.hasOwnProperty.call(async, 'default') ? async['default'] : async;\n    delegator = delegator && Object.prototype.hasOwnProperty.call(delegator, 'default') ? delegator['default'] : delegator;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    tokenHandlerFactory = tokenHandlerFactory && Object.prototype.hasOwnProperty.call(tokenHandlerFactory, 'default') ? tokenHandlerFactory['default'] : tokenHandlerFactory;\n    connectivity = connectivity && Object.prototype.hasOwnProperty.call(connectivity, 'default') ? connectivity['default'] : connectivity;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    var _defaults = {};\n    var _slice = [].slice;\n    /**\n     * Defines a proxy bound to a particular adapter\n     *\n     * @param {String} proxyName - The name of the proxy adapter to use in the returned proxy instance\n     * @param {Object} [config] - Some optional config depending of implementation,\n     *                            this object will be forwarded to the proxy adapter\n     * @returns {proxy} - The proxy instance, bound to the selected proxy adapter\n     */\n\n    function proxyFactory(proxyName, config) {\n      var proxy, delegateProxy, communicator, communicatorPromise;\n      var testDataHolder;\n      var extraCallParams = {};\n      var proxyAdapter = proxyFactory.getProvider(proxyName);\n\n      var initConfig = _.defaults(config || {}, _defaults);\n\n      var tokenHandler = tokenHandlerFactory();\n      var middlewares = {};\n      var initialized = false;\n      var onlineStatus = connectivity.isOnline();\n      /**\n       * Gets parameters merged with extra parameters\n       * @param {Object} [params]\n       * @returns {Object}\n       */\n\n      function getParams(params) {\n        var mergedParams = _.merge({}, params, extraCallParams);\n\n        extraCallParams = {};\n        return mergedParams;\n      }\n      /**\n       * Gets the aggregated list of middlewares for a particular queue name\n       * @param {String} queue - The name of the queue to get\n       * @returns {Array}\n       */\n\n\n      function getMiddlewares(queue) {\n        var list = middlewares[queue] || [];\n\n        if (middlewares.all) {\n          list = list.concat(middlewares.all);\n        }\n\n        return list;\n      }\n      /**\n       * Applies the list of registered middlewares onto the received response\n       * @param {Object} request - The request descriptor\n       * @param {String} request.command - The name of the requested command\n       * @param {Object} request.params - The map of provided parameters\n       * @param {Object} response The response descriptor\n       * @param {String} response.status The status of the response, can be either 'success' or 'error'\n       * @param {Object} response.data The full response data\n       * @returns {Promise}\n       */\n\n\n      function applyMiddlewares(request, response) {\n        // wrap each middleware to provide parameters\n        var list = _.map(getMiddlewares(request.command), function (middleware) {\n          return function (next) {\n            middleware(request, response, next);\n          };\n        }); // apply each middleware in series, then resolve or reject the promise\n\n\n        return new Promise(function (resolve, reject) {\n          async.series(list, function (err) {\n            // handle implicit error from response descriptor\n            if (!err && 'error' === response.status) {\n              err = response.data;\n            }\n\n            if (err) {\n              reject(err);\n            } else {\n              proxy.trigger('receive', response.data, 'proxy');\n              resolve(response.data);\n            }\n          });\n        });\n      }\n      /**\n       * Delegates the call to the proxy implementation and apply the middleware.\n       *\n       * @param {String} fnName - The name of the delegated method to call\n       * @returns {Promise} - The delegated method must return a promise\n       * @private\n       * @throws Error\n       */\n\n\n      function delegate(fnName) {\n        var request = {\n          command: fnName,\n          params: _slice.call(arguments, 1)\n        };\n\n        if (!initialized && !_.contains(['install', 'init'], fnName)) {\n          return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n        }\n\n        return delegateProxy.apply(null, arguments).then(function (data) {\n          // If the delegate call succeed the proxy is initialized.\n          // Place this set here to avoid to wrap the init() into another promise.\n          initialized = true; // handle successful request\n\n          return applyMiddlewares(request, {\n            status: 'success',\n            data: data\n          });\n        }).catch(function (data) {\n          // handle failed request\n          return applyMiddlewares(request, {\n            status: 'error',\n            data: data\n          });\n        });\n      }\n      /**\n       * Defines the test runner proxy\n       * @typedef {proxy}\n       */\n\n\n      proxy = eventifier({\n        /**\n         * Add a middleware\n         * @param {String} [command] The command queue in which add the middleware (default: 'all')\n         * @param {Function...} callback - A middleware callback. Must accept 3 parameters: request, response, next.\n         * @returns {proxy}\n         */\n        use: function use(command) {\n          var queue = command && _.isString(command) ? command : 'all';\n          var list = middlewares[queue] || [];\n          middlewares[queue] = list;\n\n          _.each(arguments, function (cb) {\n            if (_.isFunction(cb)) {\n              list.push(cb);\n            }\n          });\n\n          return this;\n        },\n\n        /**\n         * Install the proxy.\n         * This step let's attach some features before the proxy reallys starts (before init).\n         *\n         * @param {Map} dataHolder - the test runner data holder\n         * @returns {*}\n         */\n        install: function install(dataHolder) {\n          if (dataHolder) {\n            testDataHolder = dataHolder;\n          }\n\n          return delegate('install', initConfig);\n        },\n\n        /**\n         * Initializes the proxy\n         * @param {Object} [params] - An optional list of parameters\n         * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires init\n         */\n        init: function init(params) {\n          /**\n           * @event proxy#init\n           * @param {Promise} promise\n           * @param {Object} config\n           * @param {Object} params\n           */\n          return delegate('init', initConfig, getParams(params));\n        },\n\n        /**\n         * Uninstalls the proxy\n         * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires destroy\n         */\n        destroy: function destroy() {\n          /**\n           * @event proxy#destroy\n           * @param {Promise} promise\n           */\n          return delegate('destroy').then(function () {\n            // The proxy is now destroyed. A call to init() is mandatory to be able to use it again.\n            initialized = false; // a communicator has been invoked and...\n\n            if (communicatorPromise) {\n              return new Promise(function (resolve, reject) {\n                function destroyCommunicator() {\n                  communicator.destroy().then(resolve).catch(reject);\n                }\n\n                communicatorPromise // ... has been loaded successfully, then destroy it\n                .then(function () {\n                  destroyCommunicator();\n                }) // ...has failed to be loaded, maybe no need to destroy it\n                .catch(function () {\n                  if (communicator) {\n                    destroyCommunicator();\n                  } else {\n                    resolve();\n                  }\n                });\n              });\n            }\n          });\n        },\n\n        /**\n         * Get the map that holds the test data\n         * @returns {Map|Object} the dataHolder\n         */\n        getDataHolder: function getDataHolder() {\n          return testDataHolder;\n        },\n\n        /**\n         * Set the proxy as online\n         * @returns {proxy} chains\n         * @fires {proxy#reconnect}\n         */\n        setOnline: function setOnline() {\n          if (this.isOffline()) {\n            onlineStatus = true;\n            this.trigger('reconnect');\n          }\n\n          return this;\n        },\n\n        /**\n         * Set the proxy as offline\n         * @param {String} [source] - source of the connectivity change\n         * @returns {proxy} chains\n         * @fires {proxy#disconnect}\n         */\n        setOffline: function setOffline(source) {\n          if (this.isOnline()) {\n            onlineStatus = false;\n            this.trigger('disconnect', source);\n          }\n\n          return this;\n        },\n\n        /**\n         * Are we online ?\n         * @returns {Boolean}\n         */\n        isOnline: function isOnline() {\n          return onlineStatus;\n        },\n\n        /**\n         * Are we offline\n         * @returns {Boolean}\n         */\n        isOffline: function isOffline() {\n          return !onlineStatus;\n        },\n\n        /**\n         * For the proxy a connection error is an error object with\n         * source 'network', a 0 code and a false sent attribute.\n         *\n         * @param {Error|Object} err - the error to verify\n         * @returns {Boolean} true if a connection error.\n         */\n        isConnectivityError: function isConnectivityError(err) {\n          return _.isObject(err) && err.source === 'network' && err.code === 0 && err.sent === false;\n        },\n\n        /**\n         * Gets the security token handler\n         * @returns {tokenHandler}\n         */\n        getTokenHandler: function getTokenHandler() {\n          return tokenHandler;\n        },\n\n        /**\n         * Checks if a communication channel has been requested.\n         * @returns {Boolean}\n         */\n        hasCommunicator: function hasCommunicator() {\n          return !!communicatorPromise;\n        },\n\n        /**\n         * Gets access to the communication channel, load it if not present\n         * @returns {Promise} Returns a promise that will resolve the communication channel\n         */\n        getCommunicator: function getCommunicator() {\n          var self = this;\n\n          if (!initialized) {\n            return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n          }\n\n          if (!communicatorPromise) {\n            communicatorPromise = new Promise(function (resolve, reject) {\n              if (_.isFunction(proxyAdapter.loadCommunicator)) {\n                communicator = proxyAdapter.loadCommunicator.call(self);\n\n                if (communicator) {\n                  communicator.before('error', function (e, err) {\n                    if (self.isConnectivityError(err)) {\n                      self.setOffline('communicator');\n                    }\n                  }).on('error', function (err) {\n                    self.trigger('error', err);\n                  }).on('receive', function (response) {\n                    self.setOnline();\n                    self.trigger('receive', response, 'communicator');\n                  }).init().then(function () {\n                    return communicator.open().then(function () {\n                      resolve(communicator);\n                    }).catch(reject);\n                  }).catch(reject);\n                } else {\n                  reject(new Error('No communicator has been set up!'));\n                }\n              } else {\n                reject(new Error('The proxy provider does not have a loadCommunicator method'));\n              }\n            });\n          }\n\n          return communicatorPromise;\n        },\n\n        /**\n         * Registers a listener on a particular channel\n         * @param {String} name - The name of the channel to listen\n         * @param {Function} handler - The listener callback\n         * @returns {proxy}\n         * @throws TypeError if the name is missing or the handler is not a callback\n         */\n        channel: function channel(name, handler) {\n          if (!_.isString(name) || name.length <= 0) {\n            throw new TypeError('A channel must have a name');\n          }\n\n          if (!_.isFunction(handler)) {\n            throw new TypeError('A handler must be attached to a channel');\n          }\n\n          this.getCommunicator().then(function (communicatorInstance) {\n            communicatorInstance.channel(name, handler);\n          }) // just an empty catch to avoid any error to be displayed in the console when the communicator is not enabled\n          .catch(_.noop);\n          this.on(`channel-${name}`, handler);\n          return this;\n        },\n\n        /**\n         * Sends an messages through the communication implementation.\n         * @param {String} channel - The name of the communication channel to use\n         * @param {Object} message - The message to send\n         * @returns {Promise} The delegated provider's method must return a promise\n         */\n        send: function send(channel, message) {\n          return this.getCommunicator().then(function (communicatorInstance) {\n            return communicatorInstance.send(channel, message);\n          });\n        },\n\n        /**\n         * Add extra parameters that will be added to the init or the next callTestAction or callItemAction\n         * This enables plugins to place parameters for next calls\n         * @param {Object} params - the extra parameters\n         * @returns {proxy}\n         */\n        addCallActionParams: function addCallActionParams(params) {\n          if (_.isPlainObject(params)) {\n            _.merge(extraCallParams, params);\n          }\n\n          return this;\n        },\n\n        /**\n         * Gets the test definition data\n         * @deprecated\n         *\n         * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getTestData\n         */\n        getTestData: function getTestData() {\n          /**\n           * @event proxy#getTestData\n           * @param {Promise} promise\n           */\n          return delegate('getTestData');\n        },\n\n        /**\n         * Gets the test context\n         * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestContext: function getTestContext() {\n          /**\n           * @event proxy#getTestContext\n           * @param {Promise} promise\n           */\n          return delegate('getTestContext');\n        },\n\n        /**\n         * Gets the test map\n         * @returns {Promise} - Returns a promise. The test map object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestMap: function getTestMap() {\n          /**\n           * @event proxy#getTestMap\n           * @param {Promise} promise\n           */\n          return delegate('getTestMap');\n        },\n\n        /**\n         * Sends the test variables\n         * @param {Object} variables\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later (default: false).\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires sendVariables\n         */\n        sendVariables: function sendVariables(variables, deferred) {\n          /**\n           * @event proxy#sendVariables\n           * @param {Promise} promise\n           */\n          return delegate('sendVariables', variables, deferred);\n        },\n\n        /**\n         * Calls an action related to the test\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callTestAction\n         */\n        callTestAction: function callTestAction(action, params, deferred) {\n          /**\n           * @event proxy#callTestAction\n           * @param {Promise} promise\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callTestAction', action, getParams(params), deferred);\n        },\n\n        /**\n         * Gets an item definition by its URI, also gets its current state\n         * @param {String} uri - The URI of the item to get\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getItem\n         */\n        getItem: function getItem(uri, params) {\n          /**\n           * @event proxy#getItem\n           * @param {Promise} promise\n           * @param {String} uri\n           */\n          return delegate('getItem', uri, params);\n        },\n\n        /**\n         * Submits the state and the response of a particular item\n         * @param {String} uri - The URI of the item to update\n         * @param {Object} state - The state to submit\n         * @param {Object} response - The response object to submit\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires submitItem\n         */\n        submitItem: function submitItem(uri, state, response, params) {\n          /**\n           * @event proxy#submitItem\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {Object} state\n           * @param {Object} response\n           */\n          return delegate('submitItem', uri, state, response, getParams(params));\n        },\n\n        /**\n         * Calls an action related to a particular item\n         * @param {String} uri - The URI of the item for which call the action\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callItemAction\n         */\n        callItemAction: function callItemAction(uri, action, params, deferred) {\n          /**\n           * @event proxy#callItemAction\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callItemAction', uri, action, getParams(params), deferred);\n        },\n\n        /**\n         * Sends a telemetry signal\n         * @param {String} uri - The URI of the item for which sends the telemetry signal\n         * @param {String} signal - The name of the signal to send\n         * @param {Object} [params] - Some optional parameters to join to the signal\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires telemetry\n         */\n        telemetry: function telemetry(uri, signal, params) {\n          /**\n           * @event proxy#telemetry\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} signal\n           * @param {Object} params\n           */\n          return delegate('telemetry', uri, signal, params);\n        }\n      }); //listen for connectivty changes\n\n      connectivity.on('offline', function () {\n        proxy.setOffline('device');\n      }).on('online', function () {\n        proxy.setOnline();\n      }); // catch platform messages that come outside of the communicator component, then each is dispatched to the right channel\n\n      proxy.on('message', function (channel, message) {\n        this.trigger(`channel-${channel}`, message);\n      }).use(function (request, response, next) {\n        if (response.data && response.data.messages) {\n          // receive server messages\n          _.forEach(response.data.messages, function (msg) {\n            if (msg.channel) {\n              proxy.trigger('message', msg.channel, msg.message);\n            } else {\n              proxy.trigger('message', 'malformed', msg);\n            }\n          });\n        }\n\n        next();\n      }) //detect failing request and change the online status\n      .use(function (request, response, next) {\n        if (proxy.isConnectivityError(response.data)) {\n          proxy.setOffline('request');\n        } else if (response.data && response.data.sent === true) {\n          proxy.setOnline();\n        }\n\n        next();\n      });\n      delegateProxy = delegator(proxy, proxyAdapter, {\n        name: 'proxy',\n        wrapper: function pluginWrapper(response) {\n          return Promise.resolve(response);\n        }\n      });\n      return proxy;\n    }\n\n    var proxy = providerRegistry(proxyFactory);\n\n    return proxy;\n\n});\n\n","define('taoTests/runner/providerLoader',['core/logger', 'core/providerLoader', 'core/pluginLoader', 'core/communicator', 'taoTests/runner/runner', 'taoTests/runner/proxy', 'taoItems/runner/api/itemRunner'], function (loggerFactory, providerLoader, pluginLoader, communicator, runner, proxy, itemRunner) { 'use strict';\n\n    loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n    providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n    pluginLoader = pluginLoader && Object.prototype.hasOwnProperty.call(pluginLoader, 'default') ? pluginLoader['default'] : pluginLoader;\n    communicator = communicator && Object.prototype.hasOwnProperty.call(communicator, 'default') ? communicator['default'] : communicator;\n    runner = runner && Object.prototype.hasOwnProperty.call(runner, 'default') ? runner['default'] : runner;\n    proxy = proxy && Object.prototype.hasOwnProperty.call(proxy, 'default') ? proxy['default'] : proxy;\n    itemRunner = itemRunner && Object.prototype.hasOwnProperty.call(itemRunner, 'default') ? itemRunner['default'] : itemRunner;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2019 Open Assessment Technologies SA ;\n     */\n    const logger = loggerFactory('taoTests/runner/loader');\n    /**\n     * @typedef {Object} provider - A provider is an object exposing a list of methods with respect to the API managed by the target.\n     * @property {String} name - The name of the provider. It should be unique among all.\n     * @property {Function} init - Each provider much expose at least a method `init()`\n     * @property {Function} ... - Any other method the target is expecting\n     */\n\n    /**\n     * Load the providers that match the registration\n     * @param {Object} providers\n     * @param {provider|provider[]} providers.runner\n     * @param {provider|provider[]} [providers.proxy]\n     * @param {provider|provider[]} [providers.communicator]\n     * @param {provider|provider[]} [providers.plugins]\n     * @param {Boolean} loadFromBundle - does the loader load the modules from the sources (dev mode) or the bundles\n     * @returns {Promise<Object>} resolves with the loaded providers per provider type\n     */\n\n    function loadTestRunnerProviders() {\n      let providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let loadFromBundle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /**\n       * Default way to load the modules and register the providers\n       * @param {Object[]} providersToLoad - the list of providers\n       * @param {Object} target - a provider target (an object that use the providers), it needs to expose registerProvider\n       * @returns {Promise<Object>} resolves with the target\n       * @throws {TypeError} if the target is not a provider target\n       */\n      const loadAndRegisterProvider = function () {\n        let providersToLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let target = arguments.length > 1 ? arguments[1] : undefined;\n\n        if (!target || typeof target.registerProvider !== 'function') {\n          throw new TypeError('Trying to register providers on a target that is not a provider API');\n        }\n\n        return providerLoader().addList(providersToLoad).load(loadFromBundle).then(loadedProviders => {\n          loadedProviders.forEach(provider => target.registerProvider(provider.name, provider));\n          return target;\n        });\n      };\n      /**\n       * Available provider registration\n       */\n\n\n      const registration = {\n        runner() {\n          let runnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(runnerProviders, runner);\n        },\n\n        itemRunner() {\n          let itemRunnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return providerLoader().addList(itemRunnerProviders).load(loadFromBundle).then(loadedProviders => {\n            loadedProviders.forEach(provider => itemRunner.register(provider.name, provider));\n            return itemRunner;\n          });\n        },\n\n        communicator() {\n          let communicatorProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(communicatorProviders, communicator);\n        },\n\n        proxy() {\n          let proxyProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return loadAndRegisterProvider(proxyProviders, proxy);\n        },\n\n        plugins() {\n          let plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return pluginLoader().addList(plugins).load(loadFromBundle);\n        }\n\n      };\n\n      if (!loadFromBundle) {\n        logger.warn('All modules will be loaded from sources');\n      }\n\n      return Promise.all(Object.keys(providers).map(providerType => {\n        if (typeof registration[providerType] === 'function') {\n          logger.debug(`Start to load and register the '${providerType}' providers`);\n          const providersToLoad = Array.isArray(providers[providerType]) ? providers[providerType] : [providers[providerType]];\n          return registration[providerType](providersToLoad).then(loaded => {\n            logger.debug(`'${providerType}' providers are loaded and registered`);\n            return {\n              [providerType]: loaded\n            };\n          });\n        } else {\n          logger.warn(`Ignoring the '${providerType}' providers loading, no registration method found`);\n        }\n      })).then(results => results.reduce((acc, value) => Object.assign(acc, value), {})).catch(err => {\n        logger.error(`Error in test runner providers and plugins loading : ${err.message}`);\n        throw err;\n      });\n    }\n\n    return loadTestRunnerProviders;\n\n});\n\n","define('taoTests/runner/proxy/sample',[],function () { 'use strict';\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n\n    /**\n     * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>\n     */\n\n    /**\n     * Sample proxy definition\n     * @type {Object}\n     */\n    var sampleProxy = {\n      /**\n       * Initializes the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      init: function init() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do initialisation\n          // once the proxy has been fully initialized notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Uninstalls the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      destroy: function destroy() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do uninstall actions\n          // once the proxy has been fully uninstalled notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test definition data\n       * @param {Object} config - The config provided to the proxy factory\n       * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestData: function getTestData() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test definition data\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test context\n       * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestContext: function getTestContext() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test context object\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to the test\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callTestAction: function callTestAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets an item definition by its URI, also gets its current state\n       * @param {String} uri - The URI of the item to get\n       * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires getItem\n       */\n      getItem: function getItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the definition data and the state of the item\n          // once the item data is loaded provide the data by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Submits the state and the response of a particular item\n       * @param {String} uri - The URI of the item to update\n       * @param {Object} state - The state to submit\n       * @param {Object} response - The response object to submit\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires submitItem\n       */\n      submitItem: function submitItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // submit the state and the response of the item\n          // once the data has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to a particular item\n       * @param {String} uri - The URI of the item for which call the action\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callItemAction: function callItemAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Sends a telemetry signal\n       * @param {String} uri - The URI of the item for which sends the telemetry signal\n       * @param {String} signal - The name of the signal to send\n       * @param {Object} [params] - Some optional parameters to join to the signal\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires telemetry\n       */\n      telemetry: function telemetry() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // send the signal\n          // once the signal has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      }\n    };\n\n    return sampleProxy;\n\n});\n\n","define('taoTests/runner/runnerComponent',['lodash', 'ui/component', 'taoTests/runner/runner', 'taoTests/runner/providerLoader', 'handlebars'], function (_, component, runnerFactory, providerLoader, Handlebars) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    component = component && Object.prototype.hasOwnProperty.call(component, 'default') ? component['default'] : component;\n    runnerFactory = runnerFactory && Object.prototype.hasOwnProperty.call(runnerFactory, 'default') ? runnerFactory['default'] : runnerFactory;\n    providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n    Handlebars = Handlebars && Object.prototype.hasOwnProperty.call(Handlebars, 'default') ? Handlebars['default'] : Handlebars;\n\n    var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {\n      this.compilerInfo = [4,'>= 1.0.0'];\n    helpers = this.merge(helpers, Handlebars.helpers);  \n\n\n      return \"<div class=\\\"runner-component\\\"></div>\\n\";\n      });\n    function runnerComponentTpl(data, options, asString) {\n      var html = Template(data, options);\n      return (asString || true) ? html : $(html);\n    }\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * Validate required options from the configuration\n     * @param {Object} config\n     * @returns {Boolean} true if valid\n     * @throws {TypeError} in case of validation failure\n     */\n\n    function validateTestRunnerConfiguration() {\n      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const requiredProperties = ['providers', 'options', 'serviceCallId'];\n\n      if (typeof config !== 'object') {\n        throw new TypeError(`The runner configuration must be an object, '${typeof config}' received`);\n      }\n\n      if (requiredProperties.some(property => typeof config[property] === 'undefined')) {\n        throw new TypeError(`The runner configuration must contains at least the following properties : ${requiredProperties.join(',')}`);\n      }\n\n      return true;\n    }\n    /**\n     * Get the selected provider if set or infer it from the providers list\n     * @param {String} type - the type of provider (runner, communicator, proxy, etc.)\n     * @param {Object} config\n     * @returns {String} the selected provider for the given type\n     */\n\n\n    function getSelectedProvider() {\n      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'runner';\n      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (config.provider && config.provider[type]) {\n        return config.provider[type];\n      }\n\n      if (config.providers && config.providers[type]) {\n        const typeProviders = config.providers[type];\n\n        if (typeof typeProviders === 'object' && (typeProviders.id || typeProviders.name)) {\n          return typeProviders.id || typeProviders.name;\n        }\n\n        if (Array.isArray(typeProviders) && typeProviders.length > 0) {\n          return typeProviders[0].id || typeProviders[0].name;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Wraps a test runner into a component\n     * @param {jQuery|HTMLElement|String} container - The container in which renders the component\n     * @param {Object} config - The component configuration options\n     * @param {String} config.serviceCallId - The identifier of the test session\n     * @param {Object} config.providers\n     * @param {Object} config.options\n     * @param {Boolean} [config.loadFromBundle=false] - do we load the modules from the bundles\n     * @param {Boolean} [config.replace] - When the component is appended to its container, clears the place before\n     * @param {Number|String} [config.width] - The width in pixels, or 'auto' to use the container's width\n     * @param {Number|String} [config.height] - The height in pixels, or 'auto' to use the container's height\n     * @param {Function} [template] - An optional template for the component\n     * @returns {runnerComponent}\n     */\n\n\n    function runnerComponentFactory() {\n      let container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let template = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : runnerComponentTpl;\n      let runner = null;\n      let plugins = [];\n\n      if (!container) {\n        throw new TypeError('A container element must be defined to contain the runnerComponent');\n      }\n\n      validateTestRunnerConfiguration(config);\n      /**\n       * @typedef {runner} runnerComponent\n       */\n\n      const runnerComponent = component({\n        /**\n         * Gets the option's value\n         * @param {String} name - the option key\n         * @returns {*}\n         */\n        getOption(name) {\n          return this.config.options[name];\n        },\n\n        /**\n         * Gets the test runner\n         * @returns {runner}\n         */\n        getRunner() {\n          return runner;\n        }\n\n      }).setTemplate(template).on('init', function () {\n        //load the defined providers for the runner, the proxy, the communicator, the plugins, etc.\n        return providerLoader(config.providers, config.loadFromBundle).then(results => {\n          if (results && results.plugins) {\n            plugins = results.plugins;\n          }\n\n          this.render(container);\n          this.hide();\n        }).catch(err => this.trigger('error', err));\n      }).on('render', function () {\n        const runnerConfig = Object.assign(_.omit(this.config, ['providers']), {\n          renderTo: this.getElement()\n        });\n        runnerConfig.provider = Object.keys(this.config.providers).reduce((acc, providerType) => {\n          if (!acc[providerType] && providerType !== 'plugins') {\n            acc[providerType] = getSelectedProvider(providerType, this.config);\n          }\n\n          return acc;\n        }, runnerConfig.provider || {});\n        runner = runnerFactory(runnerConfig.provider.runner, plugins, runnerConfig).on('ready', () => {\n          _.defer(() => {\n            this.setState('ready').trigger('ready', runner).show();\n          });\n        }).on('destroy', () => runner = null).spread(this, 'error').init();\n      }).on('destroy', function () {\n        var destroying = runner && runner.destroy();\n        runner = null;\n        return destroying;\n      }).after('destroy', function () {\n        this.removeAllListeners();\n      });\n      return runnerComponent.init(config);\n    }\n\n    return runnerComponentFactory;\n\n});\n\n","define('taoTests/runner/testStore',['lodash', 'core/store', 'core/logger'], function (_, store, loggerFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    store = store && Object.prototype.hasOwnProperty.call(store, 'default') ? store['default'] : store;\n    loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA\n     *\n     */\n    /**\n     * The test store logger\n     * @type {core/logger}\n     */\n\n    var logger = loggerFactory('taoQtiTest/runner/provider/testStore');\n    /**\n     * Database name prefix (suffixed by the test identifier)\n     * to check if we use the fragmented mode\n     * or the unified mode.\n     * @type {String[]}\n     */\n\n    var legacyPrefixes = ['actions-', 'duration-', 'test-probe', 'timer-'];\n    /**\n     * List the available modes\n     */\n\n    var modes = {\n      unified: 'unified',\n      //one db per test, new mode\n      fragmented: 'fragmented' //mutliple dbs per test, legacy mode\n\n    };\n    /**\n     * Check and select the store mode.\n     * If any of the \"legacyPrefixes\" store is found, we used the fragmented mode\n     * otherwise we'll use the unified mode.\n     * @param {String} testId\n     * @param {Object} [preselectedBackend] - the storage backend\n     * @returns {Promise<String>} resolves with the mode of the current test\n     */\n\n    var selectStoreMode = function selectStoreMode(testId, preselectedBackend) {\n      return store.getAll(function validate(storeName) {\n        return _.some(legacyPrefixes, function (prefix) {\n          return !_.isEmpty(storeName) && prefix + testId === storeName;\n        });\n      }, preselectedBackend).then(function (foundStores) {\n        if (_.isArray(foundStores) && foundStores.length > 0) {\n          return modes.fragmented;\n        }\n\n        return modes.unified;\n      });\n    };\n    /**\n     * Get the store for the given test\n     *\n     * @param {String} testId - unique test instance id\n     * @returns {testStore} a 'wrapped' store instance\n     * @param {Object} [preselectedBackend] - the storage backend (automatically selected by default)\n     * @throws {TypeError} without a testId\n     */\n\n\n    function testStoreLoader(testId, preselectedBackend) {\n      var storeNames = [];\n      var volatiles = [];\n      var changeTracking = {};\n      var testMode;\n      /**\n       * Is the test using a unified store mode ?\n       * @returns {Promise<Boolean>} true if unified\n       */\n\n      var isStoreModeUnified = function isStoreModeUnified() {\n        if (_.isUndefined(testMode)) {\n          return selectStoreMode(testId, preselectedBackend).then(function (result) {\n            if (result && typeof modes[result] !== 'undefined') {\n              testMode = result;\n            } else {\n              //use the unified mode by default\n              testMode = modes.unified;\n            }\n\n            logger.debug(`Test store mode ${result} for ${testId}`);\n            return result === modes.unified;\n          });\n        }\n\n        return Promise.resolve(testMode === modes.unified);\n      };\n\n      if (_.isEmpty(testId)) {\n        throw new TypeError('The store must be identified with a unique test identifier');\n      }\n      /**\n       * Wraps a store and add the support of \"volatile\" storages\n       * @typedef {Object} testStore\n       */\n\n\n      return {\n        /**\n         * Get a wrapped store instance, that let's you use multiple stores inside one store...\n         * (or in multiple stores if the test is in legacy mode)\n         * @param {String} storeName - the name of the sub store\n         * @returns {Promise<storage>}\n         */\n        getStore: function getStore(storeName) {\n          //call when the current storge has been changed\n          //only if the store is set to track changes\n          var trackChange = function trackChange() {\n            if (_.isBoolean(changeTracking[storeName])) {\n              changeTracking[storeName] = true;\n            }\n          };\n\n          if (_.isEmpty(storeName)) {\n            throw new TypeError('A store name must be provided to get the store');\n          }\n\n          if (!_.contains(storeNames, storeName)) {\n            storeNames.push(storeName);\n          }\n\n          return isStoreModeUnified().then(function (isUnified) {\n            var loadStore;\n\n            if (isUnified) {\n              loadStore = store(testId, preselectedBackend);\n            } else {\n              loadStore = store(`${storeName}-${testId}`, preselectedBackend);\n            }\n\n            return loadStore.then(function (loadedStore) {\n              var keyPattern = new RegExp(`^${storeName}__`);\n\n              var storeKey = function storeKey(key) {\n                return isUnified ? `${storeName}__${key}` : key;\n              };\n              /**\n               * The wrapped storage\n               * @type {Object}\n               */\n\n\n              return {\n                /**\n                 * Get an item with the given key\n                 * @param {String} key\n                 * @returns {Promise<*>} with the result in resolve, undefined if nothing\n                 */\n                getItem: function getItem(key) {\n                  return loadedStore.getItem(storeKey(key));\n                },\n\n                /**\n                 * Get all store items\n                 * @returns {Promise<Object>} with a collection of items\n                 */\n                getItems: function getItems() {\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      return _.transform(entries, function (acc, entry, key) {\n                        if (keyPattern.test(key)) {\n                          acc[key.replace(keyPattern, '')] = entry;\n                        }\n\n                        return acc;\n                      }, {});\n                    });\n                  } else {\n                    return loadedStore.getItems();\n                  }\n                },\n\n                /**\n                 * Set an item with the given key\n                 * @param {String} key - the item key\n                 * @param {*} value - the item value\n                 * @returns {Promise<Boolean>} with true in resolve if added/updated\n                 */\n                setItem: function setItem(key, value) {\n                  trackChange();\n                  return loadedStore.setItem(storeKey(key), value);\n                },\n\n                /**\n                 * Remove an item with the given key\n                 * @param {String} key - the item key\n                 * @returns {Promise<Boolean>} with true in resolve if removed\n                 */\n                removeItem: function removeItem(key) {\n                  trackChange();\n                  return loadedStore.removeItem(storeKey(key));\n                },\n\n                /**\n                 * Clear the current store\n                 * @returns {Promise<Boolean>} with true in resolve once cleared\n                 */\n                clear: function clear() {\n                  trackChange();\n\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      _.forEach(entries, function (entry, key) {\n                        if (keyPattern.test(key)) {\n                          loadedStore.removeItem(key);\n                        }\n                      });\n                    });\n                  } else {\n                    return loadedStore.clear();\n                  }\n                }\n              };\n            });\n          });\n        },\n\n        /**\n         * Define the given store as \"volatile\".\n         * It means the store data can be revoked\n         * if the user change browser for example\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {testStore} chains\n         */\n        setVolatile: function setVolatile(storeName) {\n          if (!_.contains(volatiles, storeName)) {\n            volatiles.push(storeName);\n          }\n\n          return this;\n        },\n\n        /**\n         * Check the given storeId. If different from the current stored identifier\n         * we initiate the invalidation of the volatile data.\n         * @param {String} storeId - the id to check\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileIfStoreChange: function clearVolatileIfStoreChange(storeId) {\n          var self = this;\n          var shouldClear = false;\n          return store.getIdentifier(preselectedBackend).then(function (savedStoreId) {\n            if (!_.isEmpty(storeId) && !_.isEmpty(savedStoreId) && savedStoreId !== storeId) {\n              logger.info(`Storage change detected (${savedStoreId} != ${storeId}) => volatiles data wipe out !`);\n              shouldClear = true;\n            }\n\n            return shouldClear;\n          }).then(function (clear) {\n            if (clear) {\n              return self.clearVolatileStores();\n            }\n\n            return false;\n          });\n        },\n\n        /**\n         * Clear the storages marked as volatile\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileStores: function clearVolatileStores() {\n          var self = this;\n          var clearing = volatiles.map(function (storeName) {\n            return self.getStore(storeName).then(function (storeInstance) {\n              return storeInstance.clear();\n            });\n          });\n          return Promise.all(clearing).then(function (results) {\n            return results && results.length === volatiles.length;\n          });\n        },\n\n        /**\n         * Observe changes on the given store\n         *\n         * @param {String} storeName - the name of the store to observe\n         * @returns {testStore} chains\n         */\n        startChangeTracking: function startChangeTracking(storeName) {\n          changeTracking[storeName] = false;\n          return this;\n        },\n\n        /**\n         * Has the store some changes\n         *\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {Boolean} true if the given store has some changes\n         */\n        hasChanges: function hasChanges(storeName) {\n          return changeTracking[storeName] === true;\n        },\n\n        /**\n         * Reset the change listening\n         *\n         * @param {String} storeName - the name of the store\n         * @returns {testStore} chains\n         */\n        resetChanges: function resetChanges(storeName) {\n          if (_.isBoolean(changeTracking[storeName])) {\n            changeTracking[storeName] = false;\n          }\n\n          return this;\n        },\n\n        /**\n         * Remove the whole store\n         * @returns {Promise<Boolean>} true if done\n         */\n        remove: function remove() {\n          var legacyStoreExp = new RegExp(`-${testId}$`);\n          return isStoreModeUnified().then(function (isUnified) {\n            if (isUnified) {\n              return store(testId, preselectedBackend).then(function (storeInstance) {\n                return storeInstance.removeStore();\n              });\n            }\n\n            return store.removeAll(function (storeName) {\n              return legacyStoreExp.test(storeName);\n            }, preselectedBackend);\n          });\n        },\n\n        /**\n         * Wraps the identifier retrieval\n         * @returns {Promise<String>} the current store id\n         */\n        getStorageIdentifier: function getStorageIdentifier() {\n          return store.getIdentifier(preselectedBackend);\n        }\n      };\n    }\n\n    return testStoreLoader;\n\n});\n\n","\ndefine(\"taoTests/loader/taoTestsRunner.bundle\", function(){});\n","define(\"taoTests/loader/taoTestsRunner.min\", [\"taoItems/loader/taoItems.min\"], function(){});\n"]}